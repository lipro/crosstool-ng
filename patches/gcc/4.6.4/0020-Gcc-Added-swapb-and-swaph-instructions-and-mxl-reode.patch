From 7989910eb2732bb9b661c8b66adb21ab06daffcc Mon Sep 17 00:00:00 2001
From: nagaraju <nmekala@xilix.com>
Date: Tue, 28 Feb 2012 15:32:29 +0530
Subject: [PATCH 20/79] Gcc: Added swapb and swaph instructions and mxl-reoder flag And also added fast_interrupt controller

Signed-off-by: nagaraju nmekala@xilinx.com
Signed-off-by: David Holsgrove <david.holsgrove@petalogix.com>
---
 gcc/config/microblaze/microblaze-protos.h |    1 +
 gcc/config/microblaze/microblaze.c        |   47 ++++++++++++++++++++++++----
 gcc/config/microblaze/microblaze.h        |    5 ++-
 gcc/config/microblaze/microblaze.md       |   29 ++++++++++++++++--
 gcc/config/microblaze/microblaze.opt      |    4 ++
 5 files changed, 75 insertions(+), 11 deletions(-)
 mode change 100644 => 100755 gcc/config/microblaze/microblaze-protos.h
 mode change 100644 => 100755 gcc/config/microblaze/microblaze.c
 mode change 100644 => 100755 gcc/config/microblaze/microblaze.h
 mode change 100644 => 100755 gcc/config/microblaze/microblaze.md
 mode change 100644 => 100755 gcc/config/microblaze/microblaze.opt

diff --git a/gcc/config/microblaze/microblaze-protos.h b/gcc/config/microblaze/microblaze-protos.h
old mode 100644
new mode 100755
index 56dca55..aadd7d5
--- a/gcc/config/microblaze/microblaze-protos.h
+++ b/gcc/config/microblaze/microblaze-protos.h
@@ -41,6 +41,7 @@ extern void print_operand_address (FILE *, rtx);
 extern void init_cumulative_args (CUMULATIVE_ARGS *,tree, rtx);
 extern bool microblaze_legitimate_address_p (enum machine_mode, rtx, bool);
 extern int microblaze_is_interrupt_handler (void);
+extern int microblaze_is_fast_interrupt (void);
 extern rtx microblaze_return_addr (int, rtx);
 extern int simple_memory_operand (rtx, enum machine_mode);
 extern int double_memory_operand (rtx, enum machine_mode);
diff --git a/gcc/config/microblaze/microblaze.c b/gcc/config/microblaze/microblaze.c
old mode 100644
new mode 100755
index 7e8ea07..58d105b
--- a/gcc/config/microblaze/microblaze.c
+++ b/gcc/config/microblaze/microblaze.c
@@ -195,11 +195,13 @@ enum reg_class microblaze_regno_to_class[] =
 		       and epilogue and use appropriate interrupt return.
    save_volatiles    - Similiar to interrupt handler, but use normal return.  */
 int interrupt_handler;
+int fast_interrupt;
 int save_volatiles;
 
 const struct attribute_spec microblaze_attribute_table[] = {
   /* name         min_len, max_len, decl_req, type_req, fn_type, req_handler */
   {"interrupt_handler", 0,       0,     true,    false,   false,        NULL},
+  {"fast_interrupt", 0,       0,     true,    false,   false,        NULL},
   {"save_volatiles"   , 0,       0,     true,    false,   false,        NULL},
   { NULL,        	0,       0,    false,    false,   false,        NULL}
 };
@@ -1499,6 +1501,17 @@ microblaze_interrupt_function_p (tree func)
   return a != NULL_TREE;
 }
 
+static int
+microblaze_fast_interrupt_function_p (tree func)
+{
+  tree a;
+
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    return 0;
+
+  a = lookup_attribute ("fast_interrupt", DECL_ATTRIBUTES (func));
+  return a != NULL_TREE;
+}
 /* Return true if FUNC is an interrupt function which uses
    normal return, indicated by the "save_volatiles" attribute.  */
 
@@ -1523,6 +1536,11 @@ microblaze_is_interrupt_handler (void)
   return interrupt_handler;
 }
 
+int
+microblaze_is_fast_interrupt (void)
+{
+  return fast_interrupt;
+}
 /* Determine of register must be saved/restored in call.  */
 static int
 microblaze_must_save_register (int regno)
@@ -1541,7 +1559,7 @@ microblaze_must_save_register (int regno)
     {
       if (regno == MB_ABI_SUB_RETURN_ADDR_REGNUM)
 	return 1;
-      if ((interrupt_handler || save_volatiles) &&
+      if ((fast_interrupt || interrupt_handler || save_volatiles) &&
 	  (regno >= 3 && regno <= 12))
 	return 1;
     }
@@ -1555,6 +1573,12 @@ microblaze_must_save_register (int regno)
 	return 1;
     }
 
+  if (fast_interrupt)
+    {
+      if (df_regs_ever_live_p (regno)
+	  || regno == MB_ABI_MSR_SAVE_REG)
+	return 1;
+    }
   if (save_volatiles)
     {
       if (df_regs_ever_live_p (regno)
@@ -1624,6 +1648,8 @@ compute_frame_size (HOST_WIDE_INT size)
 
   interrupt_handler =
     microblaze_interrupt_function_p (current_function_decl);
+  fast_interrupt =
+    microblaze_fast_interrupt_function_p (current_function_decl);
   save_volatiles = microblaze_save_volatiles (current_function_decl);
 
   gp_reg_size = 0;
@@ -1657,7 +1683,7 @@ compute_frame_size (HOST_WIDE_INT size)
   total_size += gp_reg_size;
 
   /* Add 4 bytes for MSR.  */
-  if (interrupt_handler)
+  if (interrupt_handler || fast_interrupt)
     total_size += 4;
 
   /* No space to be allocated for link register in leaf functions with no other
@@ -2149,7 +2175,7 @@ save_restore_insns (int prologue)
   base_reg_rtx = stack_pointer_rtx;
 
   /* For interrupt_handlers, need to save/restore the MSR.  */
-  if (interrupt_handler)
+  if (interrupt_handler || fast_interrupt)
     {
       isr_mem_rtx = gen_rtx_MEM (SImode,
 				 gen_rtx_PLUS (Pmode, base_reg_rtx,
@@ -2163,7 +2189,7 @@ save_restore_insns (int prologue)
       isr_msr_rtx = gen_rtx_REG (SImode, ST_REG);
     }
 
-  if (interrupt_handler && !prologue)
+  if ((interrupt_handler && !prologue) ||( fast_interrupt && !prologue) )
     {
       emit_move_insn (isr_reg_rtx, isr_mem_rtx);
       emit_move_insn (isr_msr_rtx, isr_reg_rtx);
@@ -2183,7 +2209,7 @@ save_restore_insns (int prologue)
 	  reg_rtx = gen_rtx_REG (SImode, regno);
 	  insn = gen_rtx_PLUS (Pmode, base_reg_rtx, GEN_INT (gp_offset));
 	  mem_rtx = gen_rtx_MEM (SImode, insn);
-	  if (interrupt_handler || save_volatiles)
+	  if (interrupt_handler || save_volatiles || fast_interrupt)
 	    /* Do not optimize in flow analysis.  */
 	    MEM_VOLATILE_P (mem_rtx) = 1;
 
@@ -2201,7 +2227,7 @@ save_restore_insns (int prologue)
 	}
     }
 
-  if (interrupt_handler && prologue)
+  if ((interrupt_handler && prologue) || (fast_interrupt && prologue))
     {
       emit_move_insn (isr_reg_rtx, isr_msr_rtx);
       emit_move_insn (isr_mem_rtx, isr_reg_rtx);
@@ -2231,10 +2257,12 @@ microblaze_function_prologue (FILE * file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)
       fputs ("\t.ent\t", file);
       if (interrupt_handler && strcmp (INTERRUPT_HANDLER_NAME, fnname))
 	fputs ("_interrupt_handler", file);
+      else if (fast_interrupt && strcmp (FAST_INTERRUPT_NAME, fnname))
+	fputs ("_fast_interrupt", file);
       else
 	assemble_name (file, fnname);
       fputs ("\n", file);
-      if (!interrupt_handler)
+      if (!interrupt_handler || !fast_interrupt)
 	ASM_OUTPUT_TYPE_DIRECTIVE (file, fnname, "function");
     }
 
@@ -2589,6 +2617,11 @@ microblaze_globalize_label (FILE * stream, const char *name)
       fputs (INTERRUPT_HANDLER_NAME, stream);
       fputs ("\n\t.globl\t", stream);
     }
+  if (fast_interrupt && strcmp (name, FAST_INTERRUPT_NAME))
+    {
+      fputs (FAST_INTERRUPT_NAME, stream);
+      fputs ("\n\t.globl\t", stream);
+    }
   assemble_name (stream, name);
   fputs ("\n", stream);
 }
diff --git a/gcc/config/microblaze/microblaze.h b/gcc/config/microblaze/microblaze.h
old mode 100644
new mode 100755
index 0582bb3..e729394
--- a/gcc/config/microblaze/microblaze.h
+++ b/gcc/config/microblaze/microblaze.h
@@ -57,7 +57,7 @@ extern enum pipeline_type microblaze_pipe;
 
 /* Default target_flags if no switches are specified  */
 #define TARGET_DEFAULT      (MASK_SOFT_MUL | MASK_SOFT_DIV | MASK_SOFT_FLOAT \
-                             | TARGET_ENDIAN_DEFAULT)
+                             | TARGET_ENDIAN_DEFAULT |MASK_REORDER)
 
 /* Do we have CLZ?  */
 #define TARGET_HAS_CLZ      (TARGET_PATTERN_COMPARE && microblaze_has_clz)
@@ -81,6 +81,7 @@ extern enum pipeline_type microblaze_pipe;
 	"%{mno-xl-barrel-shift:%<mxl-barrel-shift}", 	\
 	"%{mno-xl-pattern-compare:%<mxl-pattern-compare}", \
 	"%{mxl-soft-div:%<mno-xl-soft-div}", 		\
+	"%{mxl-reorder:%<mno-xl-reorder}", 		\
 	"%{msoft-float:%<mhard-float}"
 
 /* Tell collect what flags to pass to nm.  */
@@ -783,9 +784,11 @@ do {									\
 
 /* Handle interrupt attribute.  */
 extern int interrupt_handler;
+extern int fast_interrupt;
 extern int save_volatiles;
 
 #define INTERRUPT_HANDLER_NAME "_interrupt_handler"
+#define FAST_INTERRUPT_NAME "_fast_interrupt"
 
 /* These #define added for C++.  */
 #define UNALIGNED_SHORT_ASM_OP          ".data16"
diff --git a/gcc/config/microblaze/microblaze.md b/gcc/config/microblaze/microblaze.md
old mode 100644
new mode 100755
index d4211d4..b53bfe5
--- a/gcc/config/microblaze/microblaze.md
+++ b/gcc/config/microblaze/microblaze.md
@@ -346,6 +346,29 @@
 (automata_option "time")
 (automata_option "progress")
 
+
+(define_insn "bswaphi2"
+  [(set (match_operand:HI 0 "register_operand" "+r")
+        (bswap:HI (match_dup 0)))]
+  "TARGET_REORDER"
+  "swaph %0, %0"
+)
+
+(define_insn "bswapsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (bswap:SI (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_REORDER"
+  "swapb %0, %1"
+)
+
+
+(define_insn "bswap"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (bswap:HI (match_operand:HI 1 "register_operand" "r")))]
+  "TARGET_REORDER"
+  "swaph %0, %1"
+)
+
 ;;----------------------------------------------------------------
 ;; Microblaze delay slot description
 ;;----------------------------------------------------------------
@@ -1021,7 +1044,7 @@
 (define_insn "movsi_status"
   [(set (match_operand:SI 0 "register_operand" "=d,d,z")
         (match_operand:SI 1 "register_operand" "z,d,d"))]
-  "interrupt_handler"
+  "interrupt_handler || fast_interrupt"
   "@
 	mfs\t%0,%1  #mfs
 	addk\t%0,%1,r0 #add movsi
@@ -1966,7 +1989,7 @@
   [(return)]
   "microblaze_can_use_return_insn ()"
   { 
-    if (microblaze_is_interrupt_handler ())
+    if (microblaze_is_interrupt_handler () || microblaze_is_fast_interrupt())
         return "rtid\tr14, 0\;%#";
     else
         return "rtsd\tr15, 8\;%#";
@@ -1984,7 +2007,7 @@
               (return)])]
   ""
   {	
-    if (microblaze_is_interrupt_handler ())
+    if (microblaze_is_interrupt_handler () || microblaze_is_fast_interrupt())
         return "rtid\tr14,0 \;%#";
     else
         return "rtsd\tr15,8 \;%#";
diff --git a/gcc/config/microblaze/microblaze.opt b/gcc/config/microblaze/microblaze.opt
old mode 100644
new mode 100755
index f84d9d1..426ee7a
--- a/gcc/config/microblaze/microblaze.opt
+++ b/gcc/config/microblaze/microblaze.opt
@@ -67,6 +67,10 @@ mxl-soft-mul
 Target Mask(SOFT_MUL)
 Use the soft multiply emulation (default)
 
+mxl-reorder
+Target Mask(REORDER)
+Use reorder instructions (default)
+
 mxl-soft-div
 Target Mask(SOFT_DIV)
 Use the software emulation for divides (default)
-- 
1.7.1

