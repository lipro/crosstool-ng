From a1bd306281c211650c9208a8954d300d44ac1179 Mon Sep 17 00:00:00 2001
From: David Holsgrove <david.holsgrove@petalogix.com>
Date: Tue, 10 Jan 2012 15:38:42 +1000
Subject: [PATCH 02/41] Port of Xilinx work-to-date for microblaze nptl support

Signed-off-by: David Holsgrove <david.holsgrove@petalogix.com>
---
 elf/elf.h                                          |   33 ++
 sysdeps/microblaze/Implies                         |    4 +
 sysdeps/microblaze/Makefile                        |   27 ++
 sysdeps/microblaze/Versions                        |    6 +
 sysdeps/microblaze/__longjmp.S                     |   55 +++
 sysdeps/microblaze/abort-instr.h                   |    2 +
 sysdeps/microblaze/asm-syntax.h                    |   41 ++
 sysdeps/microblaze/bits/atomic.h                   |   68 ++++
 sysdeps/microblaze/bits/byteswap.h.old             |   58 +++
 sysdeps/microblaze/bits/endian.h                   |    7 +
 sysdeps/microblaze/bits/link.h                     |   55 +++
 sysdeps/microblaze/bits/setjmp.h                   |   34 ++
 sysdeps/microblaze/bsd-_setjmp.S                   |   23 ++
 sysdeps/microblaze/bsd-setjmp.S                    |   23 ++
 sysdeps/microblaze/dl-machine.h                    |  381 ++++++++++++++++++
 sysdeps/microblaze/dl-tls.h                        |   29 ++
 sysdeps/microblaze/dl-trampoline.c                 |   10 +
 sysdeps/microblaze/elf/configure.in                |   32 ++
 sysdeps/microblaze/elf/start.S                     |   86 ++++
 sysdeps/microblaze/gccframe.h                      |   22 +
 sysdeps/microblaze/jmpbuf-unwind.h                 |   46 +++
 sysdeps/microblaze/ldsodefs.h                      |   42 ++
 sysdeps/microblaze/libc-tls.c                      |   37 ++
 sysdeps/microblaze/machine-gmon.h                  |   31 ++
 sysdeps/microblaze/memusage.h                      |   22 +
 sysdeps/microblaze/nptl/Makefile                   |   21 +
 sysdeps/microblaze/nptl/pthread_spin_lock.c        |   30 ++
 sysdeps/microblaze/nptl/pthread_spin_trylock.c     |   27 ++
 sysdeps/microblaze/nptl/pthreaddef.h               |   39 ++
 sysdeps/microblaze/nptl/tcb-offsets.sym            |   11 +
 sysdeps/microblaze/nptl/tls.h                      |  172 +++++++++
 sysdeps/microblaze/setjmp.S                        |   76 ++++
 sysdeps/microblaze/stackinfo.h                     |   28 ++
 sysdeps/microblaze/sysdep.h                        |  112 ++++++
 sysdeps/microblaze/tls-macros.h                    |   29 ++
 sysdeps/unix/sysv/linux/microblaze/Dist            |    9 +
 sysdeps/unix/sysv/linux/microblaze/Makefile        |   13 +
 sysdeps/unix/sysv/linux/microblaze/Versions        |   32 ++
 .../unix/sysv/linux/microblaze/____longjmp_chk.S   |   26 ++
 sysdeps/unix/sysv/linux/microblaze/alphasort64.c   |    1 +
 sysdeps/unix/sysv/linux/microblaze/bits/a.out.h    |    3 +
 sysdeps/unix/sysv/linux/microblaze/bits/fcntl.h    |  276 +++++++++++++
 sysdeps/unix/sysv/linux/microblaze/bits/ipc.h      |   55 +++
 sysdeps/unix/sysv/linux/microblaze/bits/mman.h     |   98 +++++
 sysdeps/unix/sysv/linux/microblaze/bits/msq.h      |   77 ++++
 sysdeps/unix/sysv/linux/microblaze/bits/poll.h     |   40 ++
 sysdeps/unix/sysv/linux/microblaze/bits/sem.h      |   87 +++++
 sysdeps/unix/sysv/linux/microblaze/bits/shm.h      |  102 +++++
 sysdeps/unix/sysv/linux/microblaze/bits/stat.h     |  163 ++++++++
 .../unix/sysv/linux/microblaze/bits/typesizes.h    |   65 ++++
 sysdeps/unix/sysv/linux/microblaze/bits/wordsize.h |    3 +
 sysdeps/unix/sysv/linux/microblaze/brk.c           |   46 +++
 sysdeps/unix/sysv/linux/microblaze/chown.c         |   66 ++++
 sysdeps/unix/sysv/linux/microblaze/clone.S         |   70 ++++
 sysdeps/unix/sysv/linux/microblaze/dl-librecon.h   |    1 +
 sysdeps/unix/sysv/linux/microblaze/fchown.c        |    1 +
 sysdeps/unix/sysv/linux/microblaze/fcntl.c         |    1 +
 sysdeps/unix/sysv/linux/microblaze/fxstat.c        |    1 +
 sysdeps/unix/sysv/linux/microblaze/getdents64.c    |    1 +
 sysdeps/unix/sysv/linux/microblaze/getegid.c       |    1 +
 sysdeps/unix/sysv/linux/microblaze/geteuid.c       |    1 +
 sysdeps/unix/sysv/linux/microblaze/getgid.c        |    1 +
 sysdeps/unix/sysv/linux/microblaze/getgroups.c     |    2 +
 sysdeps/unix/sysv/linux/microblaze/getmsg.c        |    1 +
 sysdeps/unix/sysv/linux/microblaze/getpagesize.c   |   46 +++
 sysdeps/unix/sysv/linux/microblaze/getresgid.c     |    1 +
 sysdeps/unix/sysv/linux/microblaze/getresuid.c     |    1 +
 sysdeps/unix/sysv/linux/microblaze/getrlimit.c     |    1 +
 sysdeps/unix/sysv/linux/microblaze/getrlimit64.c   |    1 +
 sysdeps/unix/sysv/linux/microblaze/getsysstats.c   |   34 ++
 sysdeps/unix/sysv/linux/microblaze/getuid.c        |    1 +
 sysdeps/unix/sysv/linux/microblaze/glob64.c        |    1 +
 sysdeps/unix/sysv/linux/microblaze/kernel_stat.h   |   43 ++
 sysdeps/unix/sysv/linux/microblaze/l               |   16 +
 sysdeps/unix/sysv/linux/microblaze/lchown.c        |    1 +
 sysdeps/unix/sysv/linux/microblaze/ldconfig.h      |    1 +
 sysdeps/unix/sysv/linux/microblaze/lockf64.c       |    1 +
 sysdeps/unix/sysv/linux/microblaze/lxstat.c        |    1 +
 sysdeps/unix/sysv/linux/microblaze/mmap.S          |   47 +++
 sysdeps/unix/sysv/linux/microblaze/msgctl.c        |  132 +++++++
 sysdeps/unix/sysv/linux/microblaze/msgget.c        |   34 ++
 sysdeps/unix/sysv/linux/microblaze/msgrcv.c        |   64 +++
 sysdeps/unix/sysv/linux/microblaze/msgsnd.c        |   47 +++
 .../unix/sysv/linux/microblaze/nptl/bits/atomic.h  |   63 +++
 .../sysv/linux/microblaze/nptl/bits/pthreadtypes.h |  181 +++++++++
 .../sysv/linux/microblaze/nptl/bits/semaphore.h    |   35 ++
 sysdeps/unix/sysv/linux/microblaze/nptl/fork.c     |    1 +
 .../unix/sysv/linux/microblaze/nptl/lowlevellock.h |  283 ++++++++++++++
 sysdeps/unix/sysv/linux/microblaze/nptl/pt-vfork.S |   21 +
 .../unix/sysv/linux/microblaze/nptl/pthread_once.c |   94 +++++
 .../linux/microblaze/nptl/unwind-forcedunwind.c    |  146 +++++++
 .../sysv/linux/microblaze/nptl/unwind-resume.c     |   87 +++++
 sysdeps/unix/sysv/linux/microblaze/nptl/unwind.h   |   31 ++
 .../unix/sysv/linux/microblaze/oldgetrlimit64.c    |    1 +
 .../unix/sysv/linux/microblaze/profil-counter.h    |    2 +
 sysdeps/unix/sysv/linux/microblaze/putmsg.c        |    1 +
 sysdeps/unix/sysv/linux/microblaze/readdir64.c     |    1 +
 sysdeps/unix/sysv/linux/microblaze/readdir64_r.c   |    1 +
 sysdeps/unix/sysv/linux/microblaze/register-dump.h |   20 +
 sysdeps/unix/sysv/linux/microblaze/scandir64.c     |    1 +
 sysdeps/unix/sysv/linux/microblaze/semctl.c        |  191 +++++++++
 sysdeps/unix/sysv/linux/microblaze/semget.c        |   38 ++
 sysdeps/unix/sysv/linux/microblaze/semop.c         |   37 ++
 sysdeps/unix/sysv/linux/microblaze/setegid.c       |    1 +
 sysdeps/unix/sysv/linux/microblaze/seteuid.c       |    1 +
 sysdeps/unix/sysv/linux/microblaze/setfsgid.c      |    1 +
 sysdeps/unix/sysv/linux/microblaze/setfsuid.c      |    1 +
 sysdeps/unix/sysv/linux/microblaze/setgid.c        |    1 +
 sysdeps/unix/sysv/linux/microblaze/setgroups.c     |    2 +
 sysdeps/unix/sysv/linux/microblaze/setregid.c      |    1 +
 sysdeps/unix/sysv/linux/microblaze/setresgid.c     |    1 +
 sysdeps/unix/sysv/linux/microblaze/setresuid.c     |    1 +
 sysdeps/unix/sysv/linux/microblaze/setreuid.c      |    1 +
 sysdeps/unix/sysv/linux/microblaze/setrlimit.c     |    1 +
 sysdeps/unix/sysv/linux/microblaze/setuid.c        |    1 +
 sysdeps/unix/sysv/linux/microblaze/shmat.c         |   56 +++
 sysdeps/unix/sysv/linux/microblaze/shmctl.c        |  156 ++++++++
 sysdeps/unix/sysv/linux/microblaze/shmdt.c         |   35 ++
 sysdeps/unix/sysv/linux/microblaze/shmget.c        |   38 ++
 .../unix/sysv/linux/microblaze/sigcontextinfo.h    |   22 +
 sysdeps/unix/sysv/linux/microblaze/socket.S        |  129 +++++++
 sysdeps/unix/sysv/linux/microblaze/sys/elf.h       |   26 ++
 sysdeps/unix/sysv/linux/microblaze/sys/procfs.h    |  124 ++++++
 sysdeps/unix/sysv/linux/microblaze/sys/reg.h       |   86 ++++
 sysdeps/unix/sysv/linux/microblaze/sys/user.h      |   77 ++++
 sysdeps/unix/sysv/linux/microblaze/syscall.S       |   34 ++
 sysdeps/unix/sysv/linux/microblaze/syscalls.list   |    5 +
 sysdeps/unix/sysv/linux/microblaze/sysdep.S        |   43 ++
 sysdeps/unix/sysv/linux/microblaze/sysdep.h        |  406 ++++++++++++++++++++
 sysdeps/unix/sysv/linux/microblaze/versionsort64.c |    1 +
 sysdeps/unix/sysv/linux/microblaze/vfork.S         |   45 +++
 sysdeps/unix/sysv/linux/microblaze/xstat.c         |    1 +
 132 files changed, 5967 insertions(+), 0 deletions(-)
 create mode 100644 sysdeps/microblaze/Implies
 create mode 100644 sysdeps/microblaze/Makefile
 create mode 100644 sysdeps/microblaze/Versions
 create mode 100644 sysdeps/microblaze/__longjmp.S
 create mode 100644 sysdeps/microblaze/abort-instr.h
 create mode 100644 sysdeps/microblaze/asm-syntax.h
 create mode 100644 sysdeps/microblaze/bits/atomic.h
 create mode 100644 sysdeps/microblaze/bits/byteswap.h.old
 create mode 100644 sysdeps/microblaze/bits/endian.h
 create mode 100644 sysdeps/microblaze/bits/link.h
 create mode 100644 sysdeps/microblaze/bits/setjmp.h
 create mode 100644 sysdeps/microblaze/bsd-_setjmp.S
 create mode 100644 sysdeps/microblaze/bsd-setjmp.S
 create mode 100644 sysdeps/microblaze/dl-machine.h
 create mode 100644 sysdeps/microblaze/dl-tls.h
 create mode 100644 sysdeps/microblaze/dl-trampoline.c
 create mode 100644 sysdeps/microblaze/elf/configure.in
 create mode 100644 sysdeps/microblaze/elf/start.S
 create mode 100644 sysdeps/microblaze/gccframe.h
 create mode 100644 sysdeps/microblaze/jmpbuf-unwind.h
 create mode 100644 sysdeps/microblaze/ldsodefs.h
 create mode 100644 sysdeps/microblaze/libc-tls.c
 create mode 100644 sysdeps/microblaze/machine-gmon.h
 create mode 100644 sysdeps/microblaze/memusage.h
 create mode 100644 sysdeps/microblaze/nptl/Makefile
 create mode 100644 sysdeps/microblaze/nptl/pthread_spin_lock.c
 create mode 100644 sysdeps/microblaze/nptl/pthread_spin_trylock.c
 create mode 100644 sysdeps/microblaze/nptl/pthreaddef.h
 create mode 100644 sysdeps/microblaze/nptl/tcb-offsets.sym
 create mode 100644 sysdeps/microblaze/nptl/tls.h
 create mode 100644 sysdeps/microblaze/setjmp.S
 create mode 100644 sysdeps/microblaze/stackinfo.h
 create mode 100644 sysdeps/microblaze/sysdep.h
 create mode 100644 sysdeps/microblaze/tls-macros.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/Dist
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/Makefile
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/Versions
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/____longjmp_chk.S
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/alphasort64.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/bits/a.out.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/bits/fcntl.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/bits/ipc.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/bits/mman.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/bits/msq.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/bits/poll.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/bits/sem.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/bits/shm.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/bits/stat.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/bits/typesizes.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/bits/wordsize.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/brk.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/chown.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/clone.S
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/dl-librecon.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/fchown.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/fcntl.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/fxstat.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/getdents64.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/getegid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/geteuid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/getgid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/getgroups.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/getmsg.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/getpagesize.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/getresgid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/getresuid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/getrlimit.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/getrlimit64.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/getsysstats.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/getuid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/glob64.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/kernel_stat.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/l
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/lchown.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/ldconfig.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/lockf64.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/lxstat.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/mmap.S
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/msgctl.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/msgget.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/msgrcv.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/msgsnd.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/nptl/bits/atomic.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/nptl/bits/pthreadtypes.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/nptl/bits/semaphore.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/nptl/fork.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/nptl/lowlevellock.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/nptl/pt-vfork.S
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/nptl/pthread_once.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/nptl/unwind-forcedunwind.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/nptl/unwind-resume.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/nptl/unwind.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/oldgetrlimit64.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/profil-counter.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/putmsg.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/readdir64.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/readdir64_r.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/register-dump.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/scandir64.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/semctl.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/semget.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/semop.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/setegid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/seteuid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/setfsgid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/setfsuid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/setgid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/setgroups.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/setregid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/setresgid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/setresuid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/setreuid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/setrlimit.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/setuid.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/shmat.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/shmctl.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/shmdt.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/shmget.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/sigcontextinfo.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/socket.S
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/sys/elf.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/sys/procfs.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/sys/reg.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/sys/user.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/syscall.S
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/syscalls.list
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/sysdep.S
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/sysdep.h
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/versionsort64.c
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/vfork.S
 create mode 100644 sysdeps/unix/sysv/linux/microblaze/xstat.c

diff --git a/elf/elf.h b/elf/elf.h
index 7c64120..ec9560e 100644
--- a/elf/elf.h
+++ b/elf/elf.h
@@ -258,6 +258,8 @@ typedef struct
    chances of collision with official or non-GNU unofficial values.  */
 
 #define EM_ALPHA	0x9026
+#define EM_NEW_MICROBLAZE   0xbd /* Xilinx MicroBlaze */
+#define EM_MICROBLAZE 0xbaab
 
 /* Legal values for e_version (version).  */
 
@@ -2790,6 +2792,37 @@ typedef Elf32_Addr Elf32_Conflict;
 #define R_M32R_GOTOFF_LO	64	/* Low 16 bit offset to GOT */
 #define R_M32R_NUM		256	/* Keep this the last entry. */
 
+/* microblaze relocations */
+#define R_MICROBLAZE_NONE	0
+#define R_MICROBLAZE_32		1
+#define R_MICROBLAZE_32_PCREL	2
+#define R_MICROBLAZE_64_PCREL	3
+#define R_MICROBLAZE_32_PCREL_LO	4
+#define R_MICROBLAZE_64		5
+#define R_MICROBLAZE_32_LO	6
+#define R_MICROBLAZE_SRO32	7
+#define R_MICROBLAZE_SRW32	8
+#define R_MICROBLAZE_64_NONE	9
+#define R_MICROBLAZE_32_SYM_OP_SYM	10
+#define R_MICROBLAZE_GNU_VTINHERIT	11
+#define R_MICROBLAZE_GNU_VTENTRY	12
+#define R_MICROBLAZE_GOTPC_64	13
+#define R_MICROBLAZE_GOT_64	14
+#define R_MICROBLAZE_PLT_64	15
+#define R_MICROBLAZE_REL	16
+#define R_MICROBLAZE_JUMP_SLOT	17
+#define R_MICROBLAZE_GLOB_DAT	18
+#define R_MICROBLAZE_GOTOFF_64	19
+#define R_MICROBLAZE_GOTOFF_32	20
+#define R_MICROBLAZE_COPY	21
+#define R_MICROBLAZE_TLS	22
+#define R_MICROBLAZE_TLSGD	23
+#define R_MICROBLAZE_TLSLD	24
+#define R_MICROBLAZE_TLSDTPMOD32	25
+#define R_MICROBLAZE_TLSDTPREL32	26
+#define R_MICROBLAZE_TLSDTPREL64	27
+#define R_MICROBLAZE_TLSGOTTPREL32	28
+#define R_MICROBLAZE_TLSTPREL32		29
 
 __END_DECLS
 
diff --git a/sysdeps/microblaze/Implies b/sysdeps/microblaze/Implies
new file mode 100644
index 0000000..73c766c
--- /dev/null
+++ b/sysdeps/microblaze/Implies
@@ -0,0 +1,4 @@
+wordsize-32
+# MicroBlaze uses IEEE 754 floating point.
+ieee754/flt-32
+ieee754/dbl-64
diff --git a/sysdeps/microblaze/Makefile b/sysdeps/microblaze/Makefile
new file mode 100644
index 0000000..9e2f96b
--- /dev/null
+++ b/sysdeps/microblaze/Makefile
@@ -0,0 +1,27 @@
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, write to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307 USA.
+
+# The mpn functions need this.  All existing 68k ports use MIT syntax.  If
+# a new port wants to use Motorola or Sony syntax, it can redefine this
+# variable.
+
+pic-ccflag = -fPIC
+
+# Make sure setjmp.c is compiled with a frame pointer
+CFLAGS-setjmp.c := -fno-omit-frame-pointer
+
+ifeq ($(subdir),elf)
+CFLAGS-rtld.c += -Wno-uninitialized -Wno-unused
+endif
diff --git a/sysdeps/microblaze/Versions b/sysdeps/microblaze/Versions
new file mode 100644
index 0000000..2b020f8
--- /dev/null
+++ b/sysdeps/microblaze/Versions
@@ -0,0 +1,6 @@
+libc {
+  GLIBC_2.0 {
+    # Functions from libgcc.
+    __divdi3; __moddi3; __udivdi3; __umoddi3;
+  }
+}
diff --git a/sysdeps/microblaze/__longjmp.S b/sysdeps/microblaze/__longjmp.S
new file mode 100644
index 0000000..64779be
--- /dev/null
+++ b/sysdeps/microblaze/__longjmp.S
@@ -0,0 +1,55 @@
+/* Copyright (C) 1991, 92, 93, 94, 95, 97 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* Jump to the position specified by ENV, causing the
+   setjmp call there to return VAL, or 1 if VAL is 0.  */
+
+/* void __longjmp (__jmp_buf env, int val) */
+
+ENTRY(__longjmp)
+    lwi   r1,r5,0
+    lwi   r2,r5,4
+    lwi   r13,r5,8
+    lwi   r14,r5,12
+    lwi   r15,r5,16
+    lwi   r16,r5,20
+    lwi   r17,r5,24
+    lwi   r18,r5,28
+    lwi   r19,r5,32
+    lwi   r20,r5,36
+    lwi   r21,r5,40
+    lwi   r22,r5,44
+    lwi   r23,r5,48
+    lwi   r24,r5,52
+    lwi   r25,r5,56
+    lwi   r26,r5,60
+    lwi   r27,r5,64
+    lwi   r28,r5,68
+    lwi   r29,r5,72
+    lwi   r30,r5,76
+    lwi   r31,r5,80
+    addk  r3,r6,r0
+    beqi  r3,L(return_1)
+    rtsd  r15,8
+    nop
+L(return_1):
+    rtsd  r15,8
+    addik r3,r0,1	/* delay slot */
+END(__longjmp)
diff --git a/sysdeps/microblaze/abort-instr.h b/sysdeps/microblaze/abort-instr.h
new file mode 100644
index 0000000..528ec90
--- /dev/null
+++ b/sysdeps/microblaze/abort-instr.h
@@ -0,0 +1,2 @@
+/* An instruction which should crash any program is `illegal'.  */
+#define ABORT_INSTRUCTION asm ("brki r0, -1") /* Hope, this works */
diff --git a/sysdeps/microblaze/asm-syntax.h b/sysdeps/microblaze/asm-syntax.h
new file mode 100644
index 0000000..52d978a
--- /dev/null
+++ b/sysdeps/microblaze/asm-syntax.h
@@ -0,0 +1,41 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef HAVE_ELF
+
+/* ELF uses byte-counts for .align, most others use log2 of count of bytes.  */
+#define ALIGNARG(log2) 1<<log2
+/* For ELF we need the `.type' directive to make shared libs work right.  */
+#define PROLOG(name) .type name,@function
+#define EPILOG(name) .size name,.-name
+/* For ELF we need to prefix register names and local labels.  */
+#ifdef __STDC__
+#define R_(r) %##r
+#define R(r) R_(r)
+#define L(label) .##label
+#else
+#define R(r) %/**/r
+#define L(label) ./**/label
+#endif
+
+#else
+
+#define ALIGNARG(log2) log2
+#define PROLOG(name) /* Nothing.  */
+#define EPILOG(name) /* Nothing.  */
+#define R(r) r
+#define L(label) label
+
+#endif
diff --git a/sysdeps/microblaze/bits/atomic.h b/sysdeps/microblaze/bits/atomic.h
new file mode 100644
index 0000000..365872c
--- /dev/null
+++ b/sysdeps/microblaze/bits/atomic.h
@@ -0,0 +1,68 @@
+/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdint.h>
+#include <sysdep.h>
+
+
+typedef int8_t atomic8_t;
+typedef uint8_t uatomic8_t;
+typedef int_fast8_t atomic_fast8_t;
+typedef uint_fast8_t uatomic_fast8_t;
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+void __microblaze_link_error (void);
+
+/* REVISIT: This is not atomic, we need to use a swap instruction */
+#define atomic_exchange_acq(mem, newvalue)				\
+   ({ __typeof (*mem) result;						\
+      result = *mem;            					\
+      *mem = newvalue;            					\
+      result; })
+
+/* Atomic compare and exchange.  These sequences are not actually atomic;
+   there is a race if *MEM != OLDVAL and we are preempted between the two
+   swaps.  */
+
+#define __arch_compare_and_exchange_val_8_acq(mem, newval, oldval) 	\
+   ({ __typeof (*mem) result;						\
+      result = *mem;            					\
+      if (result == oldval) *mem = newval;            		\
+      result; })
+
+#define __arch_compare_and_exchange_val_16_acq(mem, newval, oldval)     \
+  ({ __microblaze_link_error (); oldval; })
+
+/* REVISIT : This is not atomic */
+#define __arch_compare_and_exchange_val_32_acq(mem, newval, oldval)	\
+   ({ __typeof (*mem) result;						\
+      result = *mem;            					\
+      if (result == oldval) *mem = newval;            		\
+      result; })
+
+#define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \
+  ({ __microblaze_link_error (); oldval; })
diff --git a/sysdeps/microblaze/bits/byteswap.h.old b/sysdeps/microblaze/bits/byteswap.h.old
new file mode 100644
index 0000000..52bc5b9
--- /dev/null
+++ b/sysdeps/microblaze/bits/byteswap.h.old
@@ -0,0 +1,58 @@
+/* Macros to swap the order of bytes in integer values.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _BYTESWAP_H && !defined _NETINET_IN_H
+# error "Never use <bits/byteswap.h> directly; include <byteswap.h> instead."
+#endif
+
+#ifndef _BITS_BYTESWAP_H
+#define _BITS_BYTESWAP_H 1
+
+/* Swap bytes in 16 bit value.  We don't provide an assembler version
+   because GCC is smart enough to generate optimal assembler output, and
+   this allows for better cse.  */
+#define __bswap_16(x) \
+  ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8))
+
+/* Swap bytes in 32 bit value.  */
+#define __bswap_constant_32(x) \
+  ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) | \
+   (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
+
+#if defined __GNUC__ && __GNUC__ >= 2
+# define __bswap_32(x) \
+  __extension__							\
+  ({ unsigned int __bswap_32_v;					\
+       __bswap_32_v = __bswap_constant_32 (x);			\
+     __bswap_32_v; })
+#else
+# define __bswap_32(x) __bswap_constant_32 (x)
+#endif
+
+#if defined __GNUC__ && __GNUC__ >= 2
+/* Swap bytes in 64 bit value.  */
+# define __bswap_64(x) \
+  __extension__								\
+  ({ union { unsigned long long int __ll;				\
+	     unsigned long int __l[2]; } __bswap_64_v, __bswap_64_r;	\
+     __bswap_64_v.__ll = (x);						\
+     __bswap_64_r.__l[0] = __bswap_32 (__bswap_64_v.__l[1]);		\
+     __bswap_64_r.__l[1] = __bswap_32 (__bswap_64_v.__l[0]);		\
+     __bswap_64_r.__ll; })
+#endif
+
+#endif /* _BITS_BYTESWAP_H */
diff --git a/sysdeps/microblaze/bits/endian.h b/sysdeps/microblaze/bits/endian.h
new file mode 100644
index 0000000..6658ad4
--- /dev/null
+++ b/sysdeps/microblaze/bits/endian.h
@@ -0,0 +1,7 @@
+/* MicroBlaze is big-endian.  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __BIG_ENDIAN
diff --git a/sysdeps/microblaze/bits/link.h b/sysdeps/microblaze/bits/link.h
new file mode 100644
index 0000000..7452ac5
--- /dev/null
+++ b/sysdeps/microblaze/bits/link.h
@@ -0,0 +1,55 @@
+/* Copyright (C) 2005, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LINK_H
+# error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+
+/* Registers for entry into PLT on Microblaze.  */
+typedef struct La_microblaze_regs
+{
+  uint32_t lr_r0;
+  uint32_t lr_r1;
+  uint32_t lr_sp;
+} La_microblaze_regs;
+
+/* Return values for calls from PLT on Microblaze.  */
+typedef struct La_microblaze_retval
+{
+  uint32_t lrv_r3;
+} La_microblaze_retval;
+
+
+__BEGIN_DECLS
+
+extern Elf32_Addr la_microblaze_gnu_pltenter (Elf32_Sym *__sym, unsigned int __ndx,
+					uintptr_t *__refcook,
+					uintptr_t *__defcook,
+					La_microblaze_regs *__regs,
+					unsigned int *__flags,
+					const char *__symname,
+					long int *__framesizep);
+extern unsigned int la_microblaze_gnu_pltexit (Elf32_Sym *__sym, unsigned int __ndx,
+					 uintptr_t *__refcook,
+					 uintptr_t *__defcook,
+					 const La_microblaze_regs *__inregs,
+					 La_microblaze_retval *__outregs,
+					 const char *__symname);
+
+__END_DECLS
diff --git a/sysdeps/microblaze/bits/setjmp.h b/sysdeps/microblaze/bits/setjmp.h
new file mode 100644
index 0000000..a5703ad
--- /dev/null
+++ b/sysdeps/microblaze/bits/setjmp.h
@@ -0,0 +1,34 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Define the machine-dependent type `jmp_buf'. */
+
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H 1
+
+#if !defined _SETJMP_H && !defined _PTHREAD_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+typedef struct
+  {
+    /* There are 21 4-byte registers that shourd be saved:
+       r1, r2, r13-r31. Actually, there seems no need to save
+       r14, r16, r17, r18 (return addresses for interrupt/exception/trap). */
+    int *__sp; /* dedicated name for r1 */
+    long int __gregs[20];
+  } __jmp_buf[1];
+
+#endif
diff --git a/sysdeps/microblaze/bsd-_setjmp.S b/sysdeps/microblaze/bsd-_setjmp.S
new file mode 100644
index 0000000..5f5885e
--- /dev/null
+++ b/sysdeps/microblaze/bsd-_setjmp.S
@@ -0,0 +1,23 @@
+/* BSD `_setjmp' entry point to `sigsetjmp (..., 0)'.
+   Copyright (C) 1995-1997,2000,2001,2002,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define setjmp_name _setjmp
+#define SAVEMASK 0
+
+#include <setjmp.S>
diff --git a/sysdeps/microblaze/bsd-setjmp.S b/sysdeps/microblaze/bsd-setjmp.S
new file mode 100644
index 0000000..c2d690b
--- /dev/null
+++ b/sysdeps/microblaze/bsd-setjmp.S
@@ -0,0 +1,23 @@
+/* BSD `setjmp' entry point to `sigsetjmp (..., 1)'.
+   Copyright (C) 1995-1997,2000,2001,2002,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define setjmp_name setjmp
+#define SAVEMASK 1
+
+#include <setjmp.S>
diff --git a/sysdeps/microblaze/dl-machine.h b/sysdeps/microblaze/dl-machine.h
new file mode 100644
index 0000000..5bd11bb
--- /dev/null
+++ b/sysdeps/microblaze/dl-machine.h
@@ -0,0 +1,381 @@
+/* Machine-dependent ELF dynamic relocation inline functions.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef dl_machine_h
+#define dl_machine_h
+
+#define ELF_MACHINE_NAME "microblaze"
+
+#include <sys/param.h>
+#include <tls.h>
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int
+elf_machine_matches_host (const Elf32_Ehdr *ehdr)
+{
+  return (ehdr->e_machine == EM_MICROBLAZE ||
+		ehdr->e_machine == EM_NEW_MICROBLAZE ) ;
+}
+
+
+/* Return the link-time address of _DYNAMIC.  Conveniently, this is the
+   first element of the GOT.  This must be inlined in a function which
+   uses global data.  */
+static inline Elf32_Addr
+elf_machine_dynamic (void)
+{
+  /* This produces a GOTOFF reloc that resolves to zero at link time, so in
+     fact just loads from the GOT register directly.  By doing it without
+     an asm we can let the compiler choose any register.  */
+//  extern const Elf32_Addr _GLOBAL_OFFSET_TABLE_[] attribute_hidden;
+//  return _GLOBAL_OFFSET_TABLE_[0];
+  Elf32_Addr got_entry_0;
+  __asm__ __volatile__(
+    "lwi %0,r20,0"
+    :"=r"(got_entry_0)
+    );
+  return got_entry_0;
+}
+
+
+/* Return the run-time load address of the shared object.  */
+static inline Elf32_Addr
+elf_machine_load_address (void)
+{
+  /* Compute the difference between the runtime address of _DYNAMIC as seen
+     by a GOTOFF reference, and the link-time address found in the special
+     unrelocated first GOT entry.  */
+//  extern Elf32_Dyn bygotoff[] asm ("_DYNAMIC") attribute_hidden;
+//  return (Elf32_Addr) &bygotoff - elf_machine_dynamic ();
+  Elf32_Addr dyn;
+  __asm__ __volatile__ (
+    "addik %0,r20,_DYNAMIC@GOTOFF"
+    : "=r"(dyn)
+    );
+  return dyn - elf_machine_dynamic ();
+}
+
+
+/* Set up the loaded object described by L so its unrelocated PLT
+   entries will jump to the on-demand fixup code in dl-runtime.c.  */
+
+static inline int __attribute__ ((always_inline))
+elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
+{
+  Elf32_Addr *got;
+  extern void _dl_runtime_resolve (Elf32_Word);
+  extern void _dl_runtime_profile (Elf32_Word);
+
+#if 0 /* not yet */
+  if (l->l_info[DT_JMPREL] && lazy)
+    {
+      /* The GOT entries for functions in the PLT have not yet been
+	 filled in.  Their initial contents will arrange when called
+	 to push an offset into the .rela.plt section, push
+	 _GLOBAL_OFFSET_TABLE_[1], and then jump to
+	 _GLOBAL_OFFSET_TABLE_[2].  */
+      got = (Elf32_Addr *) D_PTR (l, l_info[DT_PLTGOT]);
+      got[1] = (Elf32_Addr) l;	/* Identify this shared object.  */
+
+      /* The got[2] entry contains the address of a function which gets
+	 called to get the address of a so far unresolved function and
+	 jump to it.  The profiling extension of the dynamic linker allows
+	 to intercept the calls to collect information.  In this case we
+	 don't store the address in the GOT so that all future calls also
+	 end in this function.  */
+      if (profile)
+	{
+	  got[2] = (Elf32_Addr) &_dl_runtime_profile;
+
+	  if (_dl_name_match_p (GLRO(dl_profile), l))
+	    {
+	      /* This is the object we are looking for.  Say that we really
+		 want profiling and the timers are started.  */
+	      GL(dl_profile_map) = l;
+	    }
+	}
+      else
+	/* This function will get called to fix up the GOT entry indicated by
+	   the offset on the stack, and then jump to the resolved address.  */
+	got[2] = (Elf32_Addr) &_dl_runtime_resolve;
+    }
+#endif
+
+  return lazy;
+}
+
+/* This code is used in dl-runtime.c to call the `fixup' function
+   and then redirect to the address it returns. */
+/* We assume that R3 contain relocation offset and R4 contains
+   link_map (_DYNAMIC). This must be consistent with the JUMP_SLOT
+   layout generated by binutils. */
+#define TRAMPOLINE_TEMPLATE(tramp_name, fixup_name) \
+"\
+    .text\n\
+    .globl  " #tramp_name "\n\
+    .type   " #tramp_name ", @function\n\
+    .align  4\n\
+" #tramp_name ":\n\
+    addik r1,r1,-40 \n\
+    swi   r5,r1,12 \n\
+    swi   r6,r1,16 \n\
+    swi   r7,r1,20 \n\
+    swi   r8,r1,24 \n\
+    swi   r9,r1,28 \n\
+    swi   r10,r1,32 \n\
+    swi   r15,r1,0 \n\
+    addk r5,r0,r4 \n\
+    brlid r15, " #fixup_name " \n\
+    addk r6,r0,r3; /* delay slot */ \n\
+    lwi   r10,r1,32 \n\
+    lwi   r9,r1,28 \n\
+    lwi   r8,r1,24 \n\
+    lwi   r7,r1,20 \n\
+    lwi   r6,r1,16 \n\
+    lwi   r5,r1,12 \n\
+    lwi   r15,r1,0 \n\
+    brad  r3 \n\
+    addik r1,r1,40; /* delay slot */ \n\
+    .size " #tramp_name ", . - " #tramp_name "\n"
+
+#ifndef PROF
+#define ELF_MACHINE_RUNTIME_TRAMPOLINE \
+asm (TRAMPOLINE_TEMPLATE (_dl_runtime_resolve, _dl_fixup) \
+     TRAMPOLINE_TEMPLATE (_dl_runtime_profile, _dl_profile_fixup));
+#else
+#define ELF_MACHINE_RUNTIME_TRAMPOLINE \
+asm (TRAMPOLINE_TEMPLATE (_dl_runtime_resolve, fixup) \
+     ".globl _dl_runtime_profile\n" \
+     ".set _dl_runtime_profile, _dl_runtime_resolve");
+#endif
+
+
+/* Mask identifying addresses reserved for the user program,
+   where the dynamic linker should not map anything.  */
+#define ELF_MACHINE_USER_ADDRESS_MASK	0x80000000UL
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.  */
+
+#define RTLD_START asm ("\
+	.text\n\
+	.globl _start\n\
+	.type _start,@function\n\
+_start:\n\
+	addk  r5,r0,r1\n\
+	addk  r3,r0,r0\n\
+1:\n\
+	addik r5,r5,4\n\
+	lw    r4,r5,r0\n\
+	bneid r4,1b\n\
+	addik r3,r3,1\n\
+	addik r3,r3,-1\n\
+	addk  r5,r0,r1\n\
+	sw    r3,r5,r0\n\
+	addik r1,r1,-24\n\
+	sw    r15,r1,r0\n\
+	brlid r15,_dl_start\n\
+	nop\n\
+	/* FALLTHRU */\n\
+\n\
+	.globl _dl_start_user\n\
+	.type _dl_start_user,@function\n\
+_dl_start_user:\n\
+	mfs   r20,rpc\n\
+	addik r20,r20,_GLOBAL_OFFSET_TABLE_+8\n\
+	lwi   r4,r20,_dl_skip_args@GOTOFF\n\
+	lwi   r5,r1,24\n\
+	rsubk r5,r4,r5\n\
+	addk  r4,r4,r4\n\
+	addk  r4,r4,r4\n\
+	addk  r1,r1,r4\n\
+	swi   r5,r1,24\n\
+	swi   r3,r1,20\n\
+	addk  r6,r5,r0\n\
+	addk  r5,r5,r5\n\
+	addk  r5,r5,r5\n\
+	addik r7,r1,28\n\
+	addk  r8,r7,r5\n\
+	addik r8,r8,4\n\
+	lwi   r5,r20,_rtld_local@GOTOFF\n\
+	brlid r15,_dl_init_internal\n\
+	nop\n\
+	lwi   r5,r1,24\n\
+	lwi   r3,r1,20\n\
+	addk  r4,r5,r5\n\
+	addk  r4,r4,r4\n\
+	addik r6,r1,28\n\
+	addk  r7,r6,r4\n\
+	addik r7,r7,4\n\
+	addik r15,r20,_dl_fini@GOTOFF\n\
+	addik r15,r15,-8\n\
+	brad  r3\n\
+	addik r1,r1,24\n\
+	nop\n\
+	.size _dl_start_user, . - _dl_start_user\n\
+	.previous");
+
+/* ELF_RTYPE_CLASS_PLT iff TYPE describes relocation of a PLT entry, so
+   PLT entries should not be allowed to define the value.
+   ELF_RTYPE_CLASS_NOCOPY iff TYPE should not be allowed to resolve to one
+   of the main executable's symbols, as for a COPY reloc.  */
+#if defined USE_TLS && (!defined RTLD_BOOTSTRAP || USE___THREAD)
+#define elf_machine_type_class(type) \
+  (((type) == R_MICROBLAZE_JUMP_SLOT || \
+    (type) == R_MICROBLAZE_TLSDTPREL32 || \
+    (type) == R_MICROBLAZE_TLSDTPMOD32 || \
+    (type) == R_MICROBLAZE_TLSTPREL32 \
+     ) * ELF_RTYPE_CLASS_PLT \
+   | ((type) == R_MICROBLAZE_COPY) * ELF_RTYPE_CLASS_COPY)
+#else
+#define elf_machine_type_class(type) \
+  (((type) == R_MICROBLAZE_JUMP_SLOT) * ELF_RTYPE_CLASS_PLT \
+   | ((type) == R_MICROBLAZE_COPY) * ELF_RTYPE_CLASS_COPY)
+#endif
+
+/* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.  */
+#define ELF_MACHINE_JMP_SLOT	R_MICROBLAZE_JUMP_SLOT
+
+/* The microblaze never uses Elf32_Rel relocations.  */
+#define ELF_MACHINE_NO_REL 1
+
+static inline Elf32_Addr
+elf_machine_fixup_plt (struct link_map *map, lookup_t t,
+		       const Elf32_Rela *reloc,
+		       Elf32_Addr *reloc_addr, Elf32_Addr value)
+{
+  return *reloc_addr = value;
+}
+
+/* Return the final value of a plt relocation. Ignore the addend.  */
+static inline Elf32_Addr
+elf_machine_plt_value (struct link_map *map, const Elf32_Rela *reloc,
+		       Elf32_Addr value)
+{
+  return value;
+}
+
+#endif /* !dl_machine_h */
+
+/* Names of the architecture-specific auditing callback functions.  */
+#define ARCH_LA_PLTENTER microblaze_gnu_pltenter
+#define ARCH_LA_PLTEXIT microblaze_gnu_pltexit
+
+#ifdef RESOLVE_MAP
+
+/* Perform the relocation specified by RELOC and SYM (which is fully resolved).
+   MAP is the object containing the reloc.  */
+
+/* Macro to put 32-bit relocation value into 2 words */
+#define PUT_REL_64(rel_addr,val) \
+  do { \
+    ((unsigned short *)(rel_addr))[1] = (val) >> 16; \
+    ((unsigned short *)(rel_addr))[3] = (val) & 0xffff; \
+  } while (0)
+
+auto inline void __attribute__ ((always_inline))
+elf_machine_rela (struct link_map *map, const Elf32_Rela *reloc,
+		  const Elf32_Sym *sym, const struct r_found_version *version,
+		  void *const reloc_addr_arg)
+{
+  Elf32_Addr *const reloc_addr = reloc_addr_arg;
+  const unsigned int r_type = ELF32_R_TYPE (reloc->r_info);
+
+  if (__builtin_expect (r_type == R_MICROBLAZE_64_PCREL, 0))
+    PUT_REL_64(reloc_addr, map->l_addr + reloc->r_addend);
+  else if (r_type == R_MICROBLAZE_REL)
+    *reloc_addr = map->l_addr + reloc->r_addend;
+  else
+    {
+      const Elf32_Sym *const refsym = sym;
+      struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
+      Elf32_Addr value = sym == NULL ? 0 : sym_map->l_addr + sym->st_value;
+
+      value += reloc->r_addend;
+      if (r_type == R_MICROBLAZE_GLOB_DAT ||
+          r_type == R_MICROBLAZE_JUMP_SLOT ||
+          r_type == R_MICROBLAZE_32)
+	{
+	  *reloc_addr = value;
+	}
+      else if (r_type == R_MICROBLAZE_COPY)
+	{
+	  if (sym != NULL && (sym->st_size > refsym->st_size
+	      || (sym->st_size < refsym->st_size && GLRO(dl_verbose))) )
+	    {
+	      const char *strtab;
+
+	      strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
+	      _dl_error_printf ("\
+%s: Symbol `%s' has different size in shared object, consider re-linking\n",
+				rtld_progname ?: "<program name unknown>",
+				strtab + refsym->st_name);
+	    }
+	  memcpy (reloc_addr_arg, (void *) value,
+		  MIN (sym->st_size, refsym->st_size));
+	}
+      else if (r_type == R_MICROBLAZE_NONE)
+	{
+	}
+#if defined USE_TLS && !defined RTLD_BOOTSTRAP
+      else if (r_type == R_MICROBLAZE_TLSDTPMOD32)
+	{
+	  if (sym_map != NULL)
+	    *reloc_addr = sym_map->l_tls_modid;
+	}
+      else if (r_type == R_MICROBLAZE_TLSDTPREL32)
+	{
+	  if (sym != NULL)
+	    *reloc_addr = sym->st_value + reloc->r_addend;
+	}
+      else if (r_type == R_MICROBLAZE_TLSTPREL32)
+	{
+	  if (sym != NULL)
+	    {
+	      CHECK_STATIC_TLS (map, sym_map);
+	      *reloc_addr = sym->st_value + sym_map->l_tls_offset + reloc->r_addend;
+	    }
+	}
+#endif
+      else
+	{
+	  _dl_reloc_bad_type (map, r_type, 0);
+	}
+    }
+}
+
+auto inline void
+elf_machine_rela_relative (Elf32_Addr l_addr, const Elf32_Rela *reloc,
+			   void *const reloc_addr_arg)
+{
+  Elf32_Addr *const reloc_addr = reloc_addr_arg;
+  PUT_REL_64(reloc_addr, l_addr + reloc->r_addend);
+}
+
+auto inline void
+elf_machine_lazy_rel (struct link_map *map,
+		      Elf32_Addr l_addr, const Elf32_Rela *reloc)
+{
+  Elf32_Addr *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  if (ELF32_R_TYPE (reloc->r_info) == R_MICROBLAZE_JUMP_SLOT)
+    *reloc_addr += l_addr;
+  else
+    _dl_reloc_bad_type (map, ELF32_R_TYPE (reloc->r_info), 1);
+}
+
+#endif /* RESOLVE_MAP */
diff --git a/sysdeps/microblaze/dl-tls.h b/sysdeps/microblaze/dl-tls.h
new file mode 100644
index 0000000..e0324a7
--- /dev/null
+++ b/sysdeps/microblaze/dl-tls.h
@@ -0,0 +1,29 @@
+/* Thread-local storage handling in the ELF dynamic linker.  ARM version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* Type used for the representation of TLS information in the GOT.  */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+
+extern void *__tls_get_addr (tls_index *ti);
diff --git a/sysdeps/microblaze/dl-trampoline.c b/sysdeps/microblaze/dl-trampoline.c
new file mode 100644
index 0000000..24ad9e4
--- /dev/null
+++ b/sysdeps/microblaze/dl-trampoline.c
@@ -0,0 +1,10 @@
+/* REVISIT */
+
+/* REVISIT: Trampolines are currently defined in dl-machine.h. Move them here. */
+#include <sysdep.h>
+#include <link.h>
+#include <elf.h>
+#include <ldsodefs.h>
+#include <dl-machine.h>
+
+ELF_MACHINE_RUNTIME_TRAMPOLINE
diff --git a/sysdeps/microblaze/elf/configure.in b/sysdeps/microblaze/elf/configure.in
new file mode 100644
index 0000000..1330fd2
--- /dev/null
+++ b/sysdeps/microblaze/elf/configure.in
@@ -0,0 +1,32 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/microblaze/elf.
+
+if test "$usetls" != no; then
+# Check for support of thread-local storage handling in assembler and
+# linker.
+AC_CACHE_CHECK(for Microblaze TLS support, libc_cv_microblaze_tls, [dnl
+cat > conftest.s <<\EOF
+       .section .tdata,"awT",@progbits
+x:
+       .word 2
+       .text
+       addik r5,r20,x@TLSGD
+       addik r5,r20,x@TLSLDM'
+EOF
+dnl
+if AC_TRY_COMMAND(${CC-cc} -c $CFLAGS conftest.s 1>&AS_MESSAGE_LOG_FD); then
+  libc_cv_microblaze_tls=yes
+else
+  libc_cv_microblaze_tls=no
+fi
+rm -f conftest*])
+if test $libc_cv_microblaze_tls = yes; then
+  AC_DEFINE(HAVE_TLS_SUPPORT)
+fi
+fi
+
+dnl It is always possible to access static and hidden symbols in an
+dnl position independent way.
+dnl NOTE: This feature was added by the GCC TLS patches.  We should test for
+dnl it.  Until we do, don't define it.
+#AC_DEFINE(PI_STATIC_AND_HIDDEN)
diff --git a/sysdeps/microblaze/elf/start.S b/sysdeps/microblaze/elf/start.S
new file mode 100644
index 0000000..e2edd2d
--- /dev/null
+++ b/sysdeps/microblaze/elf/start.S
@@ -0,0 +1,86 @@
+/* Startup code.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+	.text
+	.globl _start
+	.type _start,@function
+_start:
+	/* On entry the stack contains the following args:
+           r1+0 - argc
+           r1+4 - argv[0]
+           ...
+           r1+4*(argc-1) - argv[argc-1]
+           r1+4*argc - NULL
+           r1+4*argc + 4 - envp[0]
+           ...
+           NULL
+	*/
+#if 0 /* be safe: recalculate argc */
+	lwi	r6,r1,0
+#else
+	addk	r3,r0,r0
+	addk	r5,r1,r0
+1:
+	addik	r5,r5,4
+	lw	r4,r5,r0
+	bneid	r4,1b
+	addik	r3,r3,1
+	addik	r6,r3,-1
+	sw	r6,r1,r0
+#endif
+	addik	r7,r1,4
+	addik	r1,r1,-24
+#ifdef SHARED
+	/* Setup PIC */
+	mfs	r20,rpc
+	addik	r20,r20,_GLOBAL_OFFSET_TABLE_+8
+	lwi	r5,r20,main@GOT
+	lwi	r8,r20,__libc_csu_init@GOT
+	lwi	r9,r20,__libc_csu_fini@GOT
+	brid	__libc_start_main@PLT
+	addk	r10,r0,r0
+#else
+	addik	r5,r0,main
+	addik	r8,r0,__libc_csu_init
+	addik	r9,r0,__libc_csu_fini
+	brid	__libc_start_main
+	addk	r10,r0,r0
+#endif
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
diff --git a/sysdeps/microblaze/gccframe.h b/sysdeps/microblaze/gccframe.h
new file mode 100644
index 0000000..3bb349f
--- /dev/null
+++ b/sysdeps/microblaze/gccframe.h
@@ -0,0 +1,22 @@
+/* Definition of object in frame unwind info.  sparc version.
+   Copyright (C) 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define FIRST_PSEUDO_REGISTER 78
+
+#include <sysdeps/generic/gccframe.h>
diff --git a/sysdeps/microblaze/jmpbuf-unwind.h b/sysdeps/microblaze/jmpbuf-unwind.h
new file mode 100644
index 0000000..bfa1a64
--- /dev/null
+++ b/sysdeps/microblaze/jmpbuf-unwind.h
@@ -0,0 +1,46 @@
+/* Copyright (C) 2003, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <setjmp.h>
+#include <stdint.h>
+#include <unwind.h>
+#include <sysdep.h>
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address, demangle)		\
+  ((void *) (address) < (void *) demangle ((jmpbuf)[0].__sp))
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+
+static inline uintptr_t __attribute__ ((unused))
+_jmpbuf_sp (__jmp_buf regs)
+{
+  uintptr_t sp = regs[0].__sp;
+#ifdef PTR_DEMANGLE
+  PTR_DEMANGLE (sp);
+#endif
+  return sp;
+}
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) < _jmpbuf_sp (_jmpbuf) - (_adj))
+
+/* We use the normal longjmp for unwinding.  */
+#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
diff --git a/sysdeps/microblaze/ldsodefs.h b/sysdeps/microblaze/ldsodefs.h
new file mode 100644
index 0000000..54e0325
--- /dev/null
+++ b/sysdeps/microblaze/ldsodefs.h
@@ -0,0 +1,42 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MICROBLAZE_LDSODEFS_H
+#define _MICROBLAZE_LDSODEFS_H 1
+
+#include <elf.h>
+
+struct La_microblaze_regs;
+struct La_microblaze_retval;
+
+#define ARCH_PLTENTER_MEMBERS \
+    Elf32_Addr (*microblaze_gnu_pltenter) (Elf32_Sym *, unsigned int, uintptr_t *,	\
+				     uintptr_t *, struct La_microblaze_regs *,	\
+				     unsigned int *, const char *name,		\
+				     long int *framesizep);
+
+#define ARCH_PLTEXIT_MEMBERS \
+    unsigned int (*microblaze_gnu_pltexit) (Elf32_Sym *, unsigned int, uintptr_t *,	\
+				      uintptr_t *,				\
+				      const struct La_microblaze_regs *,		\
+				      struct La_microblaze_retval *, const char *);
+
+#include_next <ldsodefs.h>
+
+#endif
diff --git a/sysdeps/microblaze/libc-tls.c b/sysdeps/microblaze/libc-tls.c
new file mode 100644
index 0000000..f4aabc6
--- /dev/null
+++ b/sysdeps/microblaze/libc-tls.c
@@ -0,0 +1,37 @@
+/* Thread-local storage handling in the ELF dynamic linker.  ARM version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <csu/libc-tls.c>
+#include <dl-tls.h>
+
+#if USE_TLS
+
+/* On Microblaze, linker optimizations are not required, so __tls_get_addr
+   can be called even in statically linked binaries.  In this case module
+   must be always 1 and PT_TLS segment exist in the binary, otherwise it
+   would not link.  */
+
+void *
+__tls_get_addr (tls_index *ti)
+{
+  dtv_t *dtv = THREAD_DTV ();
+  return (char *) dtv[1].pointer.val + ti->ti_offset;
+}
+
+#endif
diff --git a/sysdeps/microblaze/machine-gmon.h b/sysdeps/microblaze/machine-gmon.h
new file mode 100644
index 0000000..b0f3d81
--- /dev/null
+++ b/sysdeps/microblaze/machine-gmon.h
@@ -0,0 +1,31 @@
+/* PowerPC-specific implementation of profiling support.
+   Copyright (C) 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* We need a special version of the `mcount' function because it has
+   to preserve more registers than your usual function.  */
+
+void __mcount_internal (unsigned long frompc, unsigned long selfpc);
+
+#define _MCOUNT_DECL(frompc, selfpc) \
+void __mcount_internal (unsigned long frompc, unsigned long selfpc)
+
+
+/* Define MCOUNT as empty since we have the implementation in another
+   file.  */
+#define MCOUNT
diff --git a/sysdeps/microblaze/memusage.h b/sysdeps/microblaze/memusage.h
new file mode 100644
index 0000000..5a6ceae
--- /dev/null
+++ b/sysdeps/microblaze/memusage.h
@@ -0,0 +1,22 @@
+/* Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+#define GETSP() ({ register uintptr_t stack_ptr asm ("r1"); stack_ptr; })
+
+#include <sysdeps/generic/memusage.h>
diff --git a/sysdeps/microblaze/nptl/Makefile b/sysdeps/microblaze/nptl/Makefile
new file mode 100644
index 0000000..0300693
--- /dev/null
+++ b/sysdeps/microblaze/nptl/Makefile
@@ -0,0 +1,21 @@
+# Copyright (C) 2005 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+#
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, write to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307 USA.
+
+ifeq ($(subdir),csu)
+gen-as-const-headers += tcb-offsets.sym
+endif
diff --git a/sysdeps/microblaze/nptl/pthread_spin_lock.c b/sysdeps/microblaze/nptl/pthread_spin_lock.c
new file mode 100644
index 0000000..1217b89
--- /dev/null
+++ b/sysdeps/microblaze/nptl/pthread_spin_lock.c
@@ -0,0 +1,30 @@
+/* Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <atomic.h>
+#include "pthreadP.h"
+
+int
+pthread_spin_lock (pthread_spinlock_t *lock)
+{
+  while (atomic_compare_and_exchange_val_acq (lock, 1, 0) != 0)
+   while (*lock != 0)
+    ;
+
+  return 0;
+}
diff --git a/sysdeps/microblaze/nptl/pthread_spin_trylock.c b/sysdeps/microblaze/nptl/pthread_spin_trylock.c
new file mode 100644
index 0000000..fb998d2
--- /dev/null
+++ b/sysdeps/microblaze/nptl/pthread_spin_trylock.c
@@ -0,0 +1,27 @@
+/* Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <atomic.h>
+#include "pthreadP.h"
+
+int
+pthread_spin_trylock (pthread_spinlock_t *lock)
+{
+  return atomic_compare_and_exchange_val_acq (lock, 1, 0) ? EBUSY : 0;
+}
diff --git a/sysdeps/microblaze/nptl/pthreaddef.h b/sysdeps/microblaze/nptl/pthreaddef.h
new file mode 100644
index 0000000..9dfb6ea
--- /dev/null
+++ b/sysdeps/microblaze/nptl/pthreaddef.h
@@ -0,0 +1,39 @@
+/* Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE	(2 * 1024 * 1024)
+
+/* Required stack pointer alignment at beginning.  SSE requires 16
+   bytes.  */
+#define STACK_ALIGN		16
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK	2048
+
+/* Alignment requirement for TCB.  */
+#define TCB_ALIGNMENT		16
+
+
+/* Location of current stack frame. */
+#define CURRENT_STACK_FRAME	(__builtin_frame_address (0) )
+
+
+/* XXX Until we have a better place keep the definitions here.  */
+#define __exit_thread_inline(val) \
+  INLINE_SYSCALL (exit, 1, (val))
diff --git a/sysdeps/microblaze/nptl/tcb-offsets.sym b/sysdeps/microblaze/nptl/tcb-offsets.sym
new file mode 100644
index 0000000..92cc441
--- /dev/null
+++ b/sysdeps/microblaze/nptl/tcb-offsets.sym
@@ -0,0 +1,11 @@
+#include <sysdep.h>
+#include <tls.h>
+
+--
+
+-- Derive offsets relative to the thread register.
+#define thread_offsetof(mem)	(long)(offsetof(struct pthread, mem) - sizeof(struct pthread))
+
+MULTIPLE_THREADS_OFFSET		thread_offsetof (header.multiple_threads)
+PID_OFFSET			thread_offsetof (pid)
+TID_OFFSET			thread_offsetof (tid)
diff --git a/sysdeps/microblaze/nptl/tls.h b/sysdeps/microblaze/nptl/tls.h
new file mode 100644
index 0000000..8886254
--- /dev/null
+++ b/sysdeps/microblaze/nptl/tls.h
@@ -0,0 +1,172 @@
+/* Definition for thread-local data handling.  NPTL/Microblaze version.
+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TLS_H
+#define _TLS_H	1
+
+#include <dl-sysdep.h>
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+#else /* __ASSEMBLER__ */
+# include <tcb-offsets.h>
+#endif /* __ASSEMBLER__ */
+
+
+/* We require TLS support in the tools.  */
+#ifndef HAVE_TLS_SUPPORT
+# error "TLS support is required."
+#endif
+
+/* Signal that TLS support is available.  */
+# define USE_TLS	1
+
+#ifndef __ASSEMBLER__
+
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* The TP points to the start of the thread blocks.  */
+# define TLS_DTV_AT_TP	1
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+} tcbhead_t;
+
+/* REVISIT: Assumes r21 is reserved for thread pointer */
+static inline int __microblaze_set_thread_area(void *tp)
+{
+	asm("or r21,r0,%0" : : "r" (tp));
+	return 0;
+}
+static inline void *__microblaze_get_thread_area(void)
+{
+	register void * volatile __microblaze_thread_area asm ("r21");
+	return (void *)__microblaze_thread_area;
+}
+
+# define READ_THREAD_POINTER() \
+    ({ __microblaze_get_thread_area(); })
+
+# define SET_THREAD_POINTER(x) \
+    ({ __microblaze_set_thread_area(x); })
+
+/* This is the size of the initial TCB.  */
+# define TLS_INIT_TCB_SIZE	sizeof (tcbhead_t)
+
+/* Alignment requirements for the initial TCB.  */
+# define TLS_INIT_TCB_ALIGN	16
+
+/* This is the size of the TCB.  */
+# define TLS_TCB_SIZE		sizeof (tcbhead_t)
+
+/* This is the size we need before TCB.  */
+# define TLS_PRE_TCB_SIZE	sizeof (struct pthread)
+
+/* Alignment requirements for the TCB.  */
+# define TLS_TCB_ALIGN		16
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+# define INSTALL_DTV(tcbp, dtvp) \
+  (((tcbhead_t *) (tcbp))->dtv = (dtvp) + 1)
+
+/* Install new dtv for current thread.  */
+# define INSTALL_NEW_DTV(dtv) \
+  (THREAD_DTV() = (dtv))
+
+/* Return dtv of given thread descriptor.  */
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))->dtv)
+
+/* Code to initially initialize the thread pointer. */
+# define TLS_INIT_TP(tcbp, secondcall) \
+  ({  SET_THREAD_POINTER ((tcbp)); })
+
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  (((tcbhead_t *) READ_THREAD_POINTER())->dtv)
+
+/* Return the thread descriptor for the current thread.  */
+# define THREAD_SELF \
+ (((struct pthread *) READ_THREAD_POINTER()) - 1)
+
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  CONST_THREAD_AREA (32, sizeof (struct pthread))
+
+/* Access to data in the thread descriptor is easy.  */
+#define THREAD_GETMEM(descr, member) \
+  descr->member
+#define THREAD_GETMEM_NC(descr, member, idx) \
+  descr->member[idx]
+#define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
+#define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
+
+/* Initializing the thread pointer will generate a SIGILL if the syscall
+   is not available.  */
+#define TLS_INIT_TP_EXPENSIVE 1
+
+/* Get and set the global scope generation counter in struct pthread.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
diff --git a/sysdeps/microblaze/setjmp.S b/sysdeps/microblaze/setjmp.S
new file mode 100644
index 0000000..d0656f0
--- /dev/null
+++ b/sysdeps/microblaze/setjmp.S
@@ -0,0 +1,76 @@
+/* setjmp for microblaze, ELF version.
+   Copyright (C) 1995-1997,2000,2001,2002,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* This source produces 3 functions:
+   __sigsetjmp(jmpbuf,savemask)
+   setjmp(jmpbuf) - equivalent to __sigsetjump(jmpbuf, 1)
+   _setjmp(jmpbuf) - equivalent to __sigsetjump(jmpbuf, 0)
+*/
+
+#ifndef setjmp_name
+#define setjmp_name __sigsetjmp
+#define SET_MASK_ARG
+#else
+#define SET_MASK_ARG    addik r6,r0,SAVEMASK
+#endif
+
+ENTRY (setjmp_name)
+    swi   r1,r5,0
+    swi   r2,r5,4
+    swi   r13,r5,8
+    swi   r14,r5,12
+    swi   r15,r5,16
+    swi   r16,r5,20
+    swi   r17,r5,24
+    swi   r18,r5,28
+    swi   r19,r5,32
+    swi   r20,r5,36
+    swi   r21,r5,40
+    swi   r22,r5,44
+    swi   r23,r5,48
+    swi   r24,r5,52
+    swi   r25,r5,56
+    swi   r26,r5,60
+    swi   r27,r5,64
+    swi   r28,r5,68
+    swi   r29,r5,72
+    swi   r30,r5,76
+    swi   r31,r5,80
+
+    SET_MASK_ARG
+
+	/* Make a tail call to __sigjmp_save; it takes the same args.  */
+#ifdef	PIC
+	/* We cannot use the PLT, because it requires that r20 be set, but
+           we can't save and restore our caller's value.  Instead, we do an
+           indirect jump through the GOT, using for the temporary register
+           %ecx, which is call-clobbered.  */
+    mfs   r12,rpc
+    addik r12,r12,_GLOBAL_OFFSET_TABLE_+8
+    lwi   r12,r12,__sigjmp_save@GOT
+    brad  r12
+#else
+    brid  __sigjmp_save
+#endif
+    nop
+END (setjmp_name)
+
+MICROBLAZE_HIDDEN_DEF (setjmp_name)
diff --git a/sysdeps/microblaze/stackinfo.h b/sysdeps/microblaze/stackinfo.h
new file mode 100644
index 0000000..819e819
--- /dev/null
+++ b/sysdeps/microblaze/stackinfo.h
@@ -0,0 +1,28 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+/* On microblaze the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+#endif	/* stackinfo.h */
diff --git a/sysdeps/microblaze/sysdep.h b/sysdeps/microblaze/sysdep.h
new file mode 100644
index 0000000..894ec94
--- /dev/null
+++ b/sysdeps/microblaze/sysdep.h
@@ -0,0 +1,112 @@
+/* Assembler macros for microblaze.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/generic/sysdep.h>
+
+#ifdef __ASSEMBLER__
+
+/* Syntactic details of assembler.  */
+
+# ifdef HAVE_ELF
+
+/* ELF uses byte-counts for .align, most others use log2 of count of bytes.  */
+#  define ALIGNARG(log2) 1<<log2
+/* For ELF we need the `.type' directive to make shared libs work right.  */
+#  define ASM_TYPE_DIRECTIVE(name,typearg) .type name,typearg
+#  define ASM_SIZE_DIRECTIVE(name) .size name,.-name
+
+/* In ELF C symbols are asm symbols.  */
+#  undef NO_UNDERSCORES
+#  define NO_UNDERSCORES
+
+# else
+
+#  define ALIGNARG(log2) log2
+#  define ASM_TYPE_DIRECTIVE(name,type)	/* Nothing is specified.  */
+#  define ASM_SIZE_DIRECTIVE(name)	/* Nothing is specified.  */
+
+# endif
+
+
+/* Define an entry point visible from C.
+
+   There is currently a bug in gdb which prevents us from specifying
+   incomplete stabs information.  Fake some entries here which specify
+   the current source file.  */
+# define ENTRY(name)							      \
+  .globl C_SYMBOL_NAME(name);						      \
+  ASM_TYPE_DIRECTIVE (C_SYMBOL_NAME(name),@function);			      \
+  .align ALIGNARG(2);							      \
+  C_LABEL(name)								      \
+  CALL_MCOUNT
+
+# undef END
+# define END(name) ASM_SIZE_DIRECTIVE(name)
+
+
+/* If compiled for profiling, call `_mcount' at the start of each function.  */
+# ifdef	PROF
+/* The mcount code relies on a normal frame pointer being on the stack
+   to locate our caller, so push one just for its benefit.  */
+#  define CALL_MCOUNT \
+  addik r1,r1,-4;	\
+  swi r15,r1,0;		\
+  brlid r15,JUMPTARGET(mcount); \
+  nop;			\
+  lwi r15,r1,0;		\
+  addik r1,r1,4;
+# else
+#  define CALL_MCOUNT		/* Do nothing.  */
+# endif
+
+# ifdef	NO_UNDERSCORES
+/* Since C identifiers are not normally prefixed with an underscore
+   on this system, the asm identifier `syscall_error' intrudes on the
+   C name space.  Make sure we use an innocuous name.  */
+#  define syscall_error	__syscall_error
+#  define mcount	_mcount
+# endif
+
+# define PSEUDO(name, syscall_name, args)				      \
+  .globl syscall_error;							      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+    /* jcc JUMPTARGET(syscall_error) FIXME */
+
+# define ret \
+  rtsd r15,8; nop;
+
+# undef PSEUDO_END
+# define PSEUDO_END(name)						      \
+  END (name)
+
+# undef JUMPTARGET
+# ifdef PIC
+#  define JUMPTARGET(name)	name##@PLTPC
+# else
+#  define JUMPTARGET(name)	name
+# endif
+
+/* Assembler local label name */
+#define L(name) $L##name
+
+#define MICROBLAZE_HIDDEN_DEF_REAL(x) \
+hidden_def(x)
+
+#define MICROBLAZE_HIDDEN_DEF(x) MICROBLAZE_HIDDEN_DEF_REAL(C_SYMBOL_NAME(x))
+
+#endif	/* __ASSEMBLER__ */
diff --git a/sysdeps/microblaze/tls-macros.h b/sysdeps/microblaze/tls-macros.h
new file mode 100644
index 0000000..68ec8b0
--- /dev/null
+++ b/sysdeps/microblaze/tls-macros.h
@@ -0,0 +1,29 @@
+
+#define TLS_LD(x)					\
+  ({ char *__result;					\
+     int __offset;					\
+     extern void *__tls_get_addr (void *);		\
+     asm ("mfs r20,rpc \n"				\
+	  "addik r20,r20,_GLOBAL_OFFSET_TABLE_+8\n"     \
+	  "addik %0,r20," #x "@TLSLDM"                  \
+	  : "=r" (__result));				\
+     __result = (char *)__tls_get_addr (__result);	\
+     asm ("addik %0,r0,"#x"@TLSDTPREL"                  \
+	  : "=r" (__offset));				\
+     (int *) (__result + __offset); })
+
+
+#define TLS_GD(x)					\
+  ({ int *__result;					\
+     extern void *__tls_get_addr (void *);		\
+     asm ("mfs  r20,rpc\n"				\
+	  "addik r20,r20,_GLOBAL_OFFSET_TABLE_+8\n"     \
+	  "addik %0,r20," #x "@TLSGD"			\
+	  : "=r" (__result));				\
+     (int *)__tls_get_addr (__result); })
+
+/* REVISIT: Modify these when LE and IE are supported */
+
+#define TLS_LE(x) TLS_LD(x)
+
+#define TLS_IE(x) TLS_GD(x)
diff --git a/sysdeps/unix/sysv/linux/microblaze/Dist b/sysdeps/unix/sysv/linux/microblaze/Dist
new file mode 100644
index 0000000..35fad7f
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/Dist
@@ -0,0 +1,9 @@
+clone.S
+mremap.S
+oldgetrlimit64.c
+setresuid.c
+setresgid.c
+setfsuid.c
+setfsgid.c
+sys/reg.h
+sys/procfs.h
diff --git a/sysdeps/unix/sysv/linux/microblaze/Makefile b/sysdeps/unix/sysv/linux/microblaze/Makefile
new file mode 100644
index 0000000..c9fda5d
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/Makefile
@@ -0,0 +1,13 @@
+ifeq ($(subdir),misc)
+sysdep_routines += mremap
+sysdep_headers += sys/reg.h
+endif
+
+ifeq ($(subdir),elf)
+sysdep-others += lddlibc4
+install-bin += lddlibc4
+endif
+
+ifeq ($(subdir),resource)
+sysdep_routines += oldgetrlimit64
+endif
diff --git a/sysdeps/unix/sysv/linux/microblaze/Versions b/sysdeps/unix/sysv/linux/microblaze/Versions
new file mode 100644
index 0000000..0799bf3
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/Versions
@@ -0,0 +1,32 @@
+libc {
+  GLIBC_2.0 {
+    # Exception handling support functions from libgcc
+    __register_frame; __register_frame_table; __deregister_frame;
+    __frame_state_for; __register_frame_info_table;
+
+    # c*
+    cacheflush;
+  }
+  GLIBC_2.2 {
+    # functions used in other libraries
+    __xstat64; __fxstat64; __lxstat64;
+
+    # a*
+    alphasort64;
+
+    # g*
+    glob64;
+
+    # New rlimit interface
+    getrlimit; setrlimit; getrlimit64;
+
+    # r*
+    readdir64; readdir64_r;
+
+    # s*
+    scandir64;
+
+    # v*
+    versionsort64;
+  }
+}
diff --git a/sysdeps/unix/sysv/linux/microblaze/____longjmp_chk.S b/sysdeps/unix/sysv/linux/microblaze/____longjmp_chk.S
new file mode 100644
index 0000000..79e0c80
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/____longjmp_chk.S
@@ -0,0 +1,26 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+	.text
+ENTRY (__revisit_longjmp_chk)
+	rtsd	r15,0
+	nop
+PSEUDO_END (__revisit_longjmp_chk)
+ENTRY (____longjmp_chk)
+	rtsd	r15,0
+	nop
+PSEUDO_END (____longjmp_chk)
diff --git a/sysdeps/unix/sysv/linux/microblaze/alphasort64.c b/sysdeps/unix/sysv/linux/microblaze/alphasort64.c
new file mode 100644
index 0000000..0b5ae47
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/alphasort64.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/alphasort64.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/bits/a.out.h b/sysdeps/unix/sysv/linux/microblaze/bits/a.out.h
new file mode 100644
index 0000000..0fb52c3
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/bits/a.out.h
@@ -0,0 +1,3 @@
+#ifndef __A_OUT_GNU_H__
+# error "Never use <bits/a.out.h> directly; include <a.out.h> instead."
+#endif
diff --git a/sysdeps/unix/sysv/linux/microblaze/bits/fcntl.h b/sysdeps/unix/sysv/linux/microblaze/bits/fcntl.h
new file mode 100644
index 0000000..e4b6187
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/bits/fcntl.h
@@ -0,0 +1,276 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 1995-1998, 2000, 2004, 2006, 2007, 2009
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <sys/types.h>
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
+
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		   0100	/* not fcntl */
+#define O_EXCL		   0200	/* not fcntl */
+#define O_NOCTTY	   0400	/* not fcntl */
+#define O_TRUNC		  01000	/* not fcntl */
+#define O_APPEND	  02000
+#define O_NONBLOCK	  04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		 010000
+#define O_FSYNC		 O_SYNC
+#define O_ASYNC		 020000
+
+#ifdef __USE_GNU
+# define O_DIRECTORY	 040000	/* Must be a directory.	 */
+# define O_NOFOLLOW	0100000	/* Do not follow links.	 */
+# define O_DIRECT	0200000	/* Direct disk access.	*/
+# define O_NOATIME     01000000 /* Do not set atime.  */
+# define O_CLOEXEC     02000000 /* Set close_on_exec.  */
+#endif
+
+/* For now Linux has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	0400000
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	5	/* Get record locking info.  */
+# define F_SETLK	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW	7	/* Set record locking info (blocking).	*/
+#else
+# define F_GETLK	F_GETLK64  /* Get record locking info.	*/
+# define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+# define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+#endif
+#define F_GETLK64	12	/* Get record locking info.  */
+#define F_SETLK64	13	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	14	/* Set record locking info (blocking).	*/
+
+#if defined __USE_BSD || defined __USE_UNIX98
+# define F_SETOWN	8	/* Get owner (process receiving SIGIO).  */
+# define F_GETOWN	9	/* Set owner (process receiving SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/* Set number of signal to be sent.  */
+# define F_GETSIG	11	/* Get number of signal to be sent.  */
+# define F_SETOWN_EX	15	/* Get owner (thread receiving SIGIO).  */
+# define F_GETOWN_EX	16	/* Set owner (thread receiving SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+# define F_DUPFD_CLOEXEC 1030	/* Duplicate file descriptor with
+				   close-on-exit set.  */
+#endif
+
+/* For F_[GET|SET]FD.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		0	/* Read lock.  */
+#define F_WRLCK		1	/* Write lock.	*/
+#define F_UNLCK		2	/* Remove lock.	 */
+
+/* For old implementation of bsd flock().  */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock:	*/
+# define LOCK_READ	64	/* ... which allows concurrent read operations.	 */
+# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
+# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.	 */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+#ifdef __USE_GNU
+/* Owner types.  */
+enum __pid_type
+  {
+    F_OWNER_TID = 0,	/* Kernel thread.  */
+    F_OWNER_PID,	/* Process.  */
+    F_OWNER_GID		/* Process group.  */
+  };
+
+/* Structure to use with F_GETOWN_EX and F_SETOWN_EX.  */
+struct f_owner_ex
+  {
+    enum __pid_type type;	/* Owner type of ID.  */
+    __pid_t pid;		/* ID of owner.  */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
+
+
+#ifdef __USE_GNU
+/* Flags for SYNC_FILE_RANGE.  */
+# define SYNC_FILE_RANGE_WAIT_BEFORE	1 /* Wait upon writeout of all pages
+					     in the range before performing the
+					     write.  */
+# define SYNC_FILE_RANGE_WRITE		2 /* Initiate writeout of all those
+					     dirty pages in the range which are
+					     not presently under writeback.  */
+# define SYNC_FILE_RANGE_WAIT_AFTER	4 /* Wait upon writeout of all pages in
+					     the range after performing the
+					     write.  */
+
+/* Flags for SPLICE and VMSPLICE.  */
+# define SPLICE_F_MOVE		1	/* Move pages instead of copying.  */
+# define SPLICE_F_NONBLOCK	2	/* Don't block on the pipe splicing
+					   (but we may still block on the fd
+					   we splice from/to).  */
+# define SPLICE_F_MORE		4	/* Expect more data.  */
+# define SPLICE_F_GIFT		8	/* Pages passed in are a gift.  */
+#endif
+
+__BEGIN_DECLS
+
+#ifdef __USE_GNU
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+
+/* Selective file content synch'ing.  */
+extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
+			    unsigned int __flags);
+
+
+/* Splice address range into a pipe.  */
+extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
+			 size_t __count, unsigned int __flags);
+
+/* Splice two files together.  */
+extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
+		       __off64_t *__offout, size_t __len,
+		       unsigned int __flags);
+
+/* In-kernel implementation of tee for pipe buffers.  */
+extern ssize_t tee (int __fdin, int __fdout, size_t __len,
+		    unsigned int __flags);
+
+/* Reserve storage for the data of the file associated with FD.  */
+# ifndef __USE_FILE_OFFSET64
+extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (fallocate, (int __fd, int __mode, __off64_t __offset,
+				   __off64_t __len),
+		       fallocate64);
+#  else
+#   define fallocate fallocate64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
+			__off64_t __len);
+# endif
+
+#endif
+
+__END_DECLS
diff --git a/sysdeps/unix/sysv/linux/microblaze/bits/ipc.h b/sysdeps/unix/sysv/linux/microblaze/bits/ipc.h
new file mode 100644
index 0000000..abf596c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/bits/ipc.h
@@ -0,0 +1,55 @@
+/* Copyright (C) 1995-1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipc.h> directly; include <sys/ipc.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Mode bits for `msgget', `semget', and `shmget'.  */
+#define IPC_CREAT	01000		/* Create key if key does not exist. */
+#define IPC_EXCL	02000		/* Fail if key exists.  */
+#define IPC_NOWAIT	04000		/* Return error on wait.  */
+
+/* Control commands for `msgctl', `semctl', and `shmctl'.  */
+#define IPC_RMID	0		/* Remove identifier.  */
+#define IPC_SET		1		/* Set `ipc_perm' options.  */
+#define IPC_STAT	2		/* Get `ipc_perm' options.  */
+#ifdef __USE_GNU
+# define IPC_INFO	3		/* See ipcs.  */
+#endif
+
+/* Special key values.  */
+#define IPC_PRIVATE	((__key_t) 0)	/* Private key.  */
+
+
+/* Data structure used to pass permission information to IPC operations.  */
+struct ipc_perm
+  {
+    __key_t __key;			/* Key.  */
+    __uid_t uid;			/* Owner's user ID.  */
+    __gid_t gid;			/* Owner's group ID.  */
+    __uid_t cuid;			/* Creator's user ID.  */
+    __gid_t cgid;			/* Creator's group ID.  */
+    unsigned short int mode;		/* Read/write permission.  */
+    unsigned short int __seq;		/* Sequence number.  */
+    unsigned short int __pad1;
+    unsigned long int __unused1;
+    unsigned long int __unused2;
+  };
diff --git a/sysdeps/unix/sysv/linux/microblaze/bits/mman.h b/sysdeps/unix/sysv/linux/microblaze/bits/mman.h
new file mode 100644
index 0000000..f244ebb
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/bits/mman.h
@@ -0,0 +1,98 @@
+/* Definitions for POSIX memory map interface.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_GROWSDOWN	0x00100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x00800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x01000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x02000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x04000		/* Don't check for reservations.  */
+# define MAP_POPULATE	0x08000		/* Populate (prefault) pagetables.  */
+# define MAP_NONBLOCK	0x10000		/* Do not block on IO.  */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+# define MREMAP_FIXED	2
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
diff --git a/sysdeps/unix/sysv/linux/microblaze/bits/msq.h b/sysdeps/unix/sysv/linux/microblaze/bits/msq.h
new file mode 100644
index 0000000..32a49b5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/bits/msq.h
@@ -0,0 +1,77 @@
+/* Copyright (C) 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MSG_H
+# error "Never use <bits/msq.h> directly; include <sys/msg.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Define options for message queue functions.  */
+#define MSG_NOERROR	010000	/* no error if message is too big */
+#ifdef __USE_GNU
+# define MSG_EXCEPT	020000	/* recv any msg except of specified type */
+#endif
+
+/* Types used in the structure definition.  */
+typedef unsigned long int msgqnum_t;
+typedef unsigned long int msglen_t;
+
+
+/* Structure of record for one message inside the kernel.
+   The type `struct msg' is opaque.  */
+struct msqid_ds
+{
+  struct ipc_perm msg_perm;	/* structure describing operation permission */
+  __time_t msg_stime;		/* time of last msgsnd command */
+  unsigned long int __unused1;
+  __time_t msg_rtime;		/* time of last msgrcv command */
+  unsigned long int __unused2;
+  __time_t msg_ctime;		/* time of last change */
+  unsigned long int __unused3;
+  unsigned long int __msg_cbytes; /* current number of bytes on queue */
+  msgqnum_t msg_qnum;		/* number of messages currently on queue */
+  msglen_t msg_qbytes;		/* max number of bytes allowed on queue */
+  __pid_t msg_lspid;		/* pid of last msgsnd() */
+  __pid_t msg_lrpid;		/* pid of last msgrcv() */
+  unsigned long int __unused4;
+  unsigned long int __unused5;
+};
+
+#ifdef __USE_MISC
+
+# define msg_cbytes	__msg_cbytes
+
+/* ipcs ctl commands */
+# define MSG_STAT 11
+# define MSG_INFO 12
+
+/* buffer for msgctl calls IPC_INFO, MSG_INFO */
+struct msginfo
+  {
+    int msgpool;
+    int msgmap;
+    int msgmax;
+    int msgmnb;
+    int msgmni;
+    int msgssz;
+    int msgtql;
+    unsigned short int msgseg;
+  };
+
+#endif /* __USE_MISC */
diff --git a/sysdeps/unix/sysv/linux/microblaze/bits/poll.h b/sysdeps/unix/sysv/linux/microblaze/bits/poll.h
new file mode 100644
index 0000000..468e93c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/bits/poll.h
@@ -0,0 +1,40 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_POLL_H
+# error "Never use <bits/poll.h> directly; include <sys/poll.h> instead."
+#endif
+
+/* Event types that can be polled for.  These bits may be set in `events'
+   to indicate the interesting event types; they will appear in `revents'
+   to indicate the status of the file descriptor.  */
+#define POLLIN		0x001		/* There is data to read.  */
+#define POLLPRI		0x002		/* There is urgent data to read.  */
+#define POLLOUT		0x004		/* Writing now will not block.  */
+
+#ifdef __USE_XOPEN
+/* These values are defined in XPG4.2.  */
+# define POLLRDNORM	0x040		/* Normal data may be read.  */
+# define POLLRDBAND	0x080		/* Priority data may be read.  */
+# define POLLWRNORM	POLLOUT		/* Writing now will not block.  */
+# define POLLWRBAND	0x100		/* Priority data may be written.  */
+#endif
+
+/* Event types always implicitly polled for.  These bits need not be set in
+   `events', but they will appear in `revents' to indicate the status of
+   the file descriptor.  */
+#define POLLERR		0x008		/* Error condition.  */
+#define POLLHUP		0x010		/* Hung up.  */
+#define POLLNVAL	0x020		/* Invalid polling request.  */
diff --git a/sysdeps/unix/sysv/linux/microblaze/bits/sem.h b/sysdeps/unix/sysv/linux/microblaze/bits/sem.h
new file mode 100644
index 0000000..6193501
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/bits/sem.h
@@ -0,0 +1,87 @@
+/* Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SEM_H
+# error "Never include <bits/sem.h> directly; use <sys/sem.h> instead."
+#endif
+
+#include <sys/types.h>
+
+/* Flags for `semop'.  */
+#define SEM_UNDO	0x1000		/* undo the operation on exit */
+
+/* Commands for `semctl'.  */
+#define GETPID		11		/* get sempid */
+#define GETVAL		12		/* get semval */
+#define GETALL		13		/* get all semval's */
+#define GETNCNT		14		/* get semncnt */
+#define GETZCNT		15		/* get semzcnt */
+#define SETVAL		16		/* set semval */
+#define SETALL		17		/* set all semval's */
+
+
+/* Data structure describing a set of semaphores.  */
+struct semid_ds
+{
+  struct ipc_perm sem_perm;		/* operation permission struct */
+  __time_t sem_otime;			/* last semop() time */
+  unsigned long int __unused1;
+  __time_t sem_ctime;			/* last time changed by semctl() */
+  unsigned long int __unused2;
+  unsigned long int sem_nsems;		/* number of semaphores in set */
+  unsigned long int __unused3;
+  unsigned long int __unused4;
+};
+
+/* The user should define a union like the following to use it for arguments
+   for `semctl'.
+
+   union semun
+   {
+     int val;				<= value for SETVAL
+     struct semid_ds *buf;		<= buffer for IPC_STAT & IPC_SET
+     unsigned short int *array;		<= array for GETALL & SETALL
+     struct seminfo *__buf;		<= buffer for IPC_INFO
+   };
+
+   Previous versions of this file used to define this union but this is
+   incorrect.  One can test the macro _SEM_SEMUN_UNDEFINED to see whether
+   one must define the union or not.  */
+#define _SEM_SEMUN_UNDEFINED	1
+
+#ifdef __USE_MISC
+
+/* ipcs ctl cmds */
+# define SEM_STAT 18
+# define SEM_INFO 19
+
+struct  seminfo
+{
+  int semmap;
+  int semmni;
+  int semmns;
+  int semmnu;
+  int semmsl;
+  int semopm;
+  int semume;
+  int semusz;
+  int semvmx;
+  int semaem;
+};
+
+#endif /* __USE_MISC */
diff --git a/sysdeps/unix/sysv/linux/microblaze/bits/shm.h b/sysdeps/unix/sysv/linux/microblaze/bits/shm.h
new file mode 100644
index 0000000..225b89d
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/bits/shm.h
@@ -0,0 +1,102 @@
+/* Copyright (C) 1995,1996,1997,2000,2002,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SHM_H
+# error "Never include <bits/shm.h> directly; use <sys/shm.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Permission flag for shmget.  */
+#define SHM_R		0400		/* or S_IRUGO from <linux/stat.h> */
+#define SHM_W		0200		/* or S_IWUGO from <linux/stat.h> */
+
+/* Flags for `shmat'.  */
+#define SHM_RDONLY	010000		/* attach read-only else read-write */
+#define SHM_RND		020000		/* round attach address to SHMLBA */
+#define SHM_REMAP	040000		/* take-over region on attach */
+
+/* Commands for `shmctl'.  */
+#define SHM_LOCK	11		/* lock segment (root only) */
+#define SHM_UNLOCK	12		/* unlock segment (root only) */
+
+__BEGIN_DECLS
+
+/* Segment low boundary address multiple.  */
+#define SHMLBA		(__getpagesize ())
+extern int __getpagesize (void) __THROW __attribute__ ((__const__));
+
+
+/* Type to count number of attaches.  */
+typedef unsigned long int shmatt_t;
+
+/* Data structure describing a set of semaphores.  */
+struct shmid_ds
+  {
+    struct ipc_perm shm_perm;		/* operation permission struct */
+    size_t shm_segsz;			/* size of segment in bytes */
+    __time_t shm_atime;			/* time of last shmat() */
+    unsigned long int __unused1;
+    __time_t shm_dtime;			/* time of last shmdt() */
+    unsigned long int __unused2;
+    __time_t shm_ctime;			/* time of last change by shmctl() */
+    unsigned long int __unused3;
+    __pid_t shm_cpid;			/* pid of creator */
+    __pid_t shm_lpid;			/* pid of last shmop */
+    shmatt_t shm_nattch;		/* number of current attaches */
+    unsigned long int __unused4;
+    unsigned long int __unused5;
+  };
+
+#ifdef __USE_MISC
+
+/* ipcs ctl commands */
+# define SHM_STAT 	13
+# define SHM_INFO 	14
+
+/* shm_mode upper byte flags */
+# define SHM_DEST	01000	/* segment will be destroyed on last detach */
+# define SHM_LOCKED	02000   /* segment will not be swapped */
+# define SHM_HUGETLB	04000	/* segment is mapped via hugetlb */
+
+struct	shminfo
+  {
+    unsigned long int shmmax;
+    unsigned long int shmmin;
+    unsigned long int shmmni;
+    unsigned long int shmseg;
+    unsigned long int shmall;
+    unsigned long int __unused1;
+    unsigned long int __unused2;
+    unsigned long int __unused3;
+    unsigned long int __unused4;
+  };
+
+struct shm_info
+  {
+    int used_ids;
+    unsigned long int shm_tot;	/* total allocated shm */
+    unsigned long int shm_rss;	/* total resident shm */
+    unsigned long int shm_swp;	/* total swapped shm */
+    unsigned long int swap_attempts;
+    unsigned long int swap_successes;
+  };
+
+#endif /* __USE_MISC */
+
+__END_DECLS
diff --git a/sysdeps/unix/sysv/linux/microblaze/bits/stat.h b/sysdeps/unix/sysv/linux/microblaze/bits/stat.h
new file mode 100644
index 0000000..7f2c4e3
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/bits/stat.h
@@ -0,0 +1,163 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STAT_H
+# error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
+#endif
+
+/* Versions of the `struct stat' data structure.  */
+#define _STAT_VER_LINUX_OLD	1
+#define _STAT_VER_KERNEL	1
+#define _STAT_VER_SVR4		2
+#define _STAT_VER_LINUX		3
+#define _STAT_VER		_STAT_VER_LINUX	/* The one defined below.  */
+
+/* Versions of the `xmknod' interface.  */
+#define _MKNOD_VER_LINUX	1
+#define _MKNOD_VER_SVR4		2
+#define _MKNOD_VER		_MKNOD_VER_LINUX /* The bits defined below.  */
+
+
+struct stat
+  {
+    __dev_t st_dev;			/* Device.  */
+    unsigned short int __pad1;
+#ifndef __USE_FILE_OFFSET64
+    __ino_t st_ino;			/* File serial number.	*/
+#else
+    __ino_t __st_ino;			/* 32bit file serial number.	*/
+#endif
+    __mode_t st_mode;			/* File mode.  */
+    __nlink_t st_nlink;			/* Link count.  */
+    __uid_t st_uid;			/* User ID of the file's owner.	*/
+    __gid_t st_gid;			/* Group ID of the file's group.*/
+    __dev_t st_rdev;			/* Device number, if device.  */
+    unsigned short int __pad2;
+	unsigned long	__pad3;
+#ifndef __USE_FILE_OFFSET64
+    __off_t st_size;			/* Size of file, in bytes.  */
+#else
+    __off64_t st_size;			/* Size of file, in bytes.  */
+#endif
+    __blksize_t st_blksize;		/* Optimal block size for I/O.  */
+	int		__pad4;
+
+#ifndef __USE_FILE_OFFSET64
+    __blkcnt_t st_blocks;		/* Number 512-byte blocks allocated. */
+#else
+    __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
+#endif
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
+#ifndef __USE_FILE_OFFSET64
+    unsigned long int __unused4;
+    unsigned long int __unused5;
+#else
+    __ino64_t st_ino;			/* File serial number.	*/
+#endif
+  };
+
+#ifdef __USE_LARGEFILE64
+struct stat64
+  {
+    __dev_t st_dev;			/* Device.  */
+    unsigned short int __pad1;
+
+    __ino_t __st_ino;			/* 32bit file serial number.	*/
+    __mode_t st_mode;			/* File mode.  */
+    __nlink_t st_nlink;			/* Link count.  */
+    __uid_t st_uid;			/* User ID of the file's owner.	*/
+    __gid_t st_gid;			/* Group ID of the file's group.*/
+    __dev_t st_rdev;			/* Device number, if device.  */
+    unsigned short int __pad2;
+	unsigned long	__pad3;
+    __off64_t st_size;			/* Size of file, in bytes.  */
+    __blksize_t st_blksize;		/* Optimal block size for I/O.  */
+	int		__pad4;
+    __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
+    __ino64_t st_ino;			/* File serial number.		*/
+  };
+#endif
+
+/* Tell code we have these members.  */
+#define	_STATBUF_ST_BLKSIZE
+#define _STATBUF_ST_RDEV
+/* Nanosecond resolution time values are supported.  */
+#define _STATBUF_ST_NSEC
+
+/* Encoding of the file mode.  */
+
+#define	__S_IFMT	0170000	/* These bits determine file type.  */
+
+/* File types.  */
+#define	__S_IFDIR	0040000	/* Directory.  */
+#define	__S_IFCHR	0020000	/* Character device.  */
+#define	__S_IFBLK	0060000	/* Block device.  */
+#define	__S_IFREG	0100000	/* Regular file.  */
+#define	__S_IFIFO	0010000	/* FIFO.  */
+#define	__S_IFLNK	0120000	/* Symbolic link.  */
+#define	__S_IFSOCK	0140000	/* Socket.  */
+
+/* POSIX.1b objects.  Note that these macros always evaluate to zero.  But
+   they do it by enforcing the correct use of the macros.  */
+#define __S_TYPEISMQ(buf)  ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSEM(buf) ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSHM(buf) ((buf)->st_mode - (buf)->st_mode)
+
+/* Protection bits.  */
+
+#define	__S_ISUID	04000	/* Set user ID on execution.  */
+#define	__S_ISGID	02000	/* Set group ID on execution.  */
+#define	__S_ISVTX	01000	/* Save swapped text after use (sticky).  */
+#define	__S_IREAD	0400	/* Read by owner.  */
+#define	__S_IWRITE	0200	/* Write by owner.  */
+#define	__S_IEXEC	0100	/* Execute by owner.  */
diff --git a/sysdeps/unix/sysv/linux/microblaze/bits/typesizes.h b/sysdeps/unix/sysv/linux/microblaze/bits/typesizes.h
new file mode 100644
index 0000000..55d92b9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/bits/typesizes.h
@@ -0,0 +1,65 @@
+/* bits/typesizes.h -- underlying types for *_t.  Generic version.
+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+#define __DEV_T_TYPE		__UQUAD_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__ULONGWORD_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U32_TYPE
+#define __NLINK_T_TYPE		__UWORD_TYPE
+#define __OFF_T_TYPE		__SLONGWORD_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__ULONGWORD_TYPE
+#define __RLIM64_T_TYPE		__UQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SLONGWORD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __DADDR_T_TYPE		__S32_TYPE
+#define __SWBLK_T_TYPE		__SLONGWORD_TYPE
+#define __KEY_T_TYPE		__S32_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		void *
+#define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
+#define __FSID_T_TYPE		struct { int __val[2]; }
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+#endif /* bits/typesizes.h */
diff --git a/sysdeps/unix/sysv/linux/microblaze/bits/wordsize.h b/sysdeps/unix/sysv/linux/microblaze/bits/wordsize.h
new file mode 100644
index 0000000..23d379a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/bits/wordsize.h
@@ -0,0 +1,3 @@
+/* Determine the wordsize from the preprocessor defines.  */
+
+# define __WORDSIZE	32
diff --git a/sysdeps/unix/sysv/linux/microblaze/brk.c b/sysdeps/unix/sysv/linux/microblaze/brk.c
new file mode 100644
index 0000000..77a1564
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/brk.c
@@ -0,0 +1,46 @@
+/* brk system call.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+void *__curbrk = 0;
+
+/* Old braindamage in GCC's crtstuff.c requires this symbol in an attempt
+   to work around different old braindamage in the old Linux/x86 ELF
+   dynamic linker.  Sigh.  */
+weak_alias (__curbrk, ___brk_addr)
+
+int
+__brk (void *addr)
+{
+  void *newbrk;
+
+  INTERNAL_SYSCALL_DECL (err);
+  newbrk = (void *) INTERNAL_SYSCALL (brk, err, 1, addr);
+  __curbrk = newbrk;
+
+  if (newbrk < addr)
+    {
+      __set_errno (ENOMEM);
+      return -1;
+    }
+
+  return 0;
+}
+weak_alias (__brk, brk)
diff --git a/sysdeps/unix/sysv/linux/microblaze/chown.c b/sysdeps/unix/sysv/linux/microblaze/chown.c
new file mode 100644
index 0000000..e34cb9a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/chown.c
@@ -0,0 +1,66 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <linux/posix_types.h>
+#include "kernel-features.h"
+
+#ifdef __NR_chown32
+# if __ASSUME_32BITUIDS == 0
+/* This variable is shared with all files that need to check for 32bit
+   uids.  */
+extern int __libc_missing_32bit_uids;
+# endif
+#endif /* __NR_chown32 */
+
+int
+__chown (const char *file, uid_t owner, gid_t group)
+{
+#if __ASSUME_32BITUIDS > 0
+  return INLINE_SYSCALL (chown32, 3, CHECK_STRING (file), owner, group);
+#else
+# ifdef __NR_chown32
+  if (__libc_missing_32bit_uids <= 0)
+    {
+      int result;
+      int saved_errno = errno;
+
+      result = INLINE_SYSCALL (chown32, 3, CHECK_STRING (file), owner, group);
+      if (result == 0 || errno != ENOSYS)
+	return result;
+
+      __set_errno (saved_errno);
+      __libc_missing_32bit_uids = 1;
+    }
+# endif /* __NR_chown32 */
+
+  if (((owner + 1) > (gid_t) ((__kernel_uid_t) -1U))
+      || ((group + 1) > (gid_t) ((__kernel_gid_t) -1U)))
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  return INLINE_SYSCALL (chown, 3, CHECK_STRING (file), owner, group);
+#endif
+}
+libc_hidden_def (__chown)
+weak_alias (__chown, chown)
diff --git a/sysdeps/unix/sysv/linux/microblaze/clone.S b/sysdeps/unix/sysv/linux/microblaze/clone.S
new file mode 100644
index 0000000..23a6f2c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/clone.S
@@ -0,0 +1,70 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* clone is even more special than fork as it mucks with stacks
+   and invokes a function in the right context after its all over.  */
+
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+	     pid_t *ptid, struct user_desc *tls, pid_t *ctid);
+
+   REVISIT: Should match kernel function which currently expects stack_size
+   in r7 (__clone2). Let us put a 0 there.
+
+   INCOMING: r5 (fn), r6(child_stack), r7(flags), r8(arg), r9(ptid)
+             r10 (tls), 28(r1) ctid
+   OUTGOING:
+
+   linux: arch/microblaze/entry.S: sys_clone expects
+	r5 (flags)  r6(child stack) r7(stack_size) r8(ptid) r9(ctid)
+*/
+
+        .text
+ENTRY (__clone)
+	addik	r3,r0,-EINVAL
+	beqi	r5,SYSCALL_ERROR_LABEL	; // Invalid func
+	beqi	r6,SYSCALL_ERROR_LABEL	; // Invalid stack
+	addik	r6,r6,-8
+	swi	r5,r6,0			; // Push fn onto child's stack
+	swi	r8,r6,4			; // Push arg for child
+	addk	r5,r0,r7		; // flags for clone() syscall
+	addk	r7,r0,r0                ; // REVISIT Unnecessary argument
+	addk	r8,r0,r9		; // parent tid ptr
+	lwi	r9,r1,28		; // child tid ptr
+	addik	r12,r0,SYS_ify(clone)
+	brki	r14,8
+	addk	r0,r0,r0
+	addik	r4,r0,-4095
+	cmpu	r4,r4,r3
+	bgei	r4,SYSCALL_ERROR_LABEL
+	beqi	r3,L(thread_start)
+	rtsd	r15,8
+	nop
+
+L(thread_start):
+	lwi	r12,r1,0		; // fn
+	lwi	r5,r1,4			; // arg
+	brald	r15,r12
+	nop
+	addk	r5,r0,r3
+	addik	r12,r0,SYS_ify(exit)
+	brki	r14,8
+	nop
+PSEUDO_END(__clone)
+
+weak_alias(__clone,clone)
diff --git a/sysdeps/unix/sysv/linux/microblaze/dl-librecon.h b/sysdeps/unix/sysv/linux/microblaze/dl-librecon.h
new file mode 100644
index 0000000..dbb4e75
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/dl-librecon.h
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/dl-librecon.h>
diff --git a/sysdeps/unix/sysv/linux/microblaze/fchown.c b/sysdeps/unix/sysv/linux/microblaze/fchown.c
new file mode 100644
index 0000000..3a69ecc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/fchown.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fchown.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/fcntl.c b/sysdeps/unix/sysv/linux/microblaze/fcntl.c
new file mode 100644
index 0000000..ea951bc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/fcntl.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fcntl.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/fxstat.c b/sysdeps/unix/sysv/linux/microblaze/fxstat.c
new file mode 100644
index 0000000..4f219f0
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/fxstat.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fxstat.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/getdents64.c b/sysdeps/unix/sysv/linux/microblaze/getdents64.c
new file mode 100644
index 0000000..0c75fb5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/getdents64.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getdents64.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/getegid.c b/sysdeps/unix/sysv/linux/microblaze/getegid.c
new file mode 100644
index 0000000..37b4b4a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/getegid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getegid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/geteuid.c b/sysdeps/unix/sysv/linux/microblaze/geteuid.c
new file mode 100644
index 0000000..ebcb555
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/geteuid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/geteuid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/getgid.c b/sysdeps/unix/sysv/linux/microblaze/getgid.c
new file mode 100644
index 0000000..0a4d606
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/getgid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getgid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/getgroups.c b/sysdeps/unix/sysv/linux/microblaze/getgroups.c
new file mode 100644
index 0000000..102ea24
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/getgroups.c
@@ -0,0 +1,2 @@
+/* We also have to rewrite the kernel gid_t to the user land type.  */
+#include <sysdeps/unix/sysv/linux/i386/getgroups.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/getmsg.c b/sysdeps/unix/sysv/linux/microblaze/getmsg.c
new file mode 100644
index 0000000..3a1fa08
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/getmsg.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getmsg.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/getpagesize.c b/sysdeps/unix/sysv/linux/microblaze/getpagesize.c
new file mode 100644
index 0000000..6b4a50c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/getpagesize.c
@@ -0,0 +1,46 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/param.h>
+#include <errno.h>
+
+#include <ldsodefs.h>
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+/* Return the system page size.  */
+int
+__getpagesize ()
+{
+#ifdef __NR_getpagesize
+  int result;
+#endif
+
+  if (GLRO(dl_pagesize) != 0)
+    return GLRO(dl_pagesize);
+
+#ifdef __NR_getpagesize
+  INTERNAL_SYSCALL_DECL (err);
+  result = INTERNAL_SYSCALL (getpagesize, err, 0);
+  /* The only possible error is ENOSYS.  */
+  if (!INTERNAL_SYSCALL_ERROR_P (result, err))
+    return result;
+#endif
+
+  return 4096;
+}
+libc_hidden_def (__getpagesize)
+weak_alias (__getpagesize, getpagesize)
diff --git a/sysdeps/unix/sysv/linux/microblaze/getresgid.c b/sysdeps/unix/sysv/linux/microblaze/getresgid.c
new file mode 100644
index 0000000..b703a41
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/getresgid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getresgid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/getresuid.c b/sysdeps/unix/sysv/linux/microblaze/getresuid.c
new file mode 100644
index 0000000..0b14cef
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/getresuid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getresuid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/getrlimit.c b/sysdeps/unix/sysv/linux/microblaze/getrlimit.c
new file mode 100644
index 0000000..fc06dbd
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/getrlimit.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getrlimit.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/getrlimit64.c b/sysdeps/unix/sysv/linux/microblaze/getrlimit64.c
new file mode 100644
index 0000000..fef018f
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/getrlimit64.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getrlimit64.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/getsysstats.c b/sysdeps/unix/sysv/linux/microblaze/getsysstats.c
new file mode 100644
index 0000000..fc65dd4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/getsysstats.c
@@ -0,0 +1,34 @@
+/* Determine various system internal values.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* We need to define a special parser for /proc/cpuinfo.  */
+#define GET_NPROCS_PARSER(FD, BUFFER, CP, RE, BUFFER_END, RESULT)	  \
+  do									  \
+    {									  \
+      (RESULT) = 0;							  \
+      /* Read all lines and count the lines starting with the string	  \
+	 "CPU:".  We don't have to fear extremely long lines since	  \
+	 the kernel will not generate them.  8192 bytes are really	  \
+	 enough.  */							  \
+      char *l;								  \
+      while ((l = next_line (FD, BUFFER, &CP, &RE, BUFFER_END)) != NULL)  \
+	if (strncmp (l, "CPU:", 4) == 0)	      	     		  \
+	  ++(RESULT);							  \
+    }									  \
+  while (0)
+
+#include <sysdeps/unix/sysv/linux/getsysstats.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/getuid.c b/sysdeps/unix/sysv/linux/microblaze/getuid.c
new file mode 100644
index 0000000..d682c79
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/getuid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getuid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/glob64.c b/sysdeps/unix/sysv/linux/microblaze/glob64.c
new file mode 100644
index 0000000..82a9a29
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/glob64.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/glob64.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/kernel_stat.h b/sysdeps/unix/sysv/linux/microblaze/kernel_stat.h
new file mode 100644
index 0000000..6d635a0
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/kernel_stat.h
@@ -0,0 +1,43 @@
+/* Definition of `struct stat' used in the kernel..  */
+struct kernel_stat
+  {
+    unsigned short int st_dev;
+    unsigned short int __pad1;
+#define _HAVE___PAD1
+    unsigned long int st_ino;
+    unsigned short int st_mode;
+    unsigned short int st_nlink;
+    unsigned short int st_uid;
+    unsigned short int st_gid;
+    unsigned short int st_rdev;
+    unsigned short int __pad2;
+#define _HAVE___PAD2
+    unsigned long __pad3;
+#define _HAVE___PAD3
+    unsigned long int st_size;
+    unsigned long int st_blksize;
+    int __pad4;
+#define _HAVE___PAD4
+    unsigned long int st_blocks;
+    struct timespec st_atim;
+    struct timespec st_mtim;
+    struct timespec st_ctim;
+    unsigned long int __unused4;
+#define _HAVE___UNUSED4
+    unsigned long int __unused5;
+#define _HAVE___UNUSED5
+  };
+
+#define _HAVE_STAT___UNUSED4
+#define _HAVE_STAT___UNUSED5
+#define _HAVE_STAT___PAD1
+#define _HAVE_STAT___PAD2
+#define _HAVE_STAT___PAD3
+#define _HAVE_STAT___PAD4
+#define _HAVE_STAT_NSEC
+#define _HAVE_STAT64___PAD1
+#define _HAVE_STAT64___PAD2
+#define _HAVE_STAT64___PAD3
+#define _HAVE_STAT64___PAD4
+#define _HAVE_STAT64___ST_INO
+#define _HAVE_STAT64_NSEC
diff --git a/sysdeps/unix/sysv/linux/microblaze/l b/sysdeps/unix/sysv/linux/microblaze/l
new file mode 100644
index 0000000..6ea64c4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/l
@@ -0,0 +1,16 @@
+/* Determine various system internal values.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
diff --git a/sysdeps/unix/sysv/linux/microblaze/lchown.c b/sysdeps/unix/sysv/linux/microblaze/lchown.c
new file mode 100644
index 0000000..c89de99
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/lchown.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/lchown.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/ldconfig.h b/sysdeps/unix/sysv/linux/microblaze/ldconfig.h
new file mode 100644
index 0000000..953f192
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/ldconfig.h
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/ldconfig.h>
diff --git a/sysdeps/unix/sysv/linux/microblaze/lockf64.c b/sysdeps/unix/sysv/linux/microblaze/lockf64.c
new file mode 100644
index 0000000..a88f5a7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/lockf64.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/lockf64.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/lxstat.c b/sysdeps/unix/sysv/linux/microblaze/lxstat.c
new file mode 100644
index 0000000..0efa0ae
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/lxstat.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/lxstat.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/mmap.S b/sysdeps/unix/sysv/linux/microblaze/mmap.S
new file mode 100644
index 0000000..2086ea1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/mmap.S
@@ -0,0 +1,47 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+#define EINVAL 22
+	.text
+ENTRY (__mmap)
+	addik	r3,r0,-EINVAL
+	andi	r4,r10,0xfff
+	bnei	r4,L(skip)
+	addik	r12,r0,SYS_ify(mmap2)
+	sra	r10,r10
+	sra	r10,r10
+	sra	r10,r10
+	sra	r10,r10
+	sra	r10,r10
+	sra	r10,r10
+	sra	r10,r10
+	sra	r10,r10
+	sra	r10,r10
+	sra	r10,r10
+	sra	r10,r10
+	sra	r10,r10 ;	/* mmap2 takes the offset in pages. */
+	brki	r14,8
+	nop
+L(skip):
+	addik	r4,r0,-4095
+	cmpu	r4,r4,r3
+	bgei	r4,SYSCALL_ERROR_LABEL
+	rtsd	r15,8
+	nop
+PSEUDO_END (__mmap)
+
+weak_alias (__mmap, mmap)
diff --git a/sysdeps/unix/sysv/linux/microblaze/msgctl.c b/sysdeps/unix/sysv/linux/microblaze/msgctl.c
new file mode 100644
index 0000000..c217bf5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/msgctl.c
@@ -0,0 +1,132 @@
+/* Copyright (C) 1995, 1997, 1998, 2000, 2002, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/msg.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <string.h>
+#include <sys/syscall.h>
+#include <shlib-compat.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+struct __old_msqid_ds
+{
+  struct __old_ipc_perm msg_perm;	/* structure describing operation permission */
+  struct msg *__unbounded __msg_first;	/* pointer to first message on queue */
+  struct msg *__unbounded __msg_last;	/* pointer to last message on queue */
+  __time_t msg_stime;			/* time of last msgsnd command */
+  __time_t msg_rtime;			/* time of last msgrcv command */
+  __time_t msg_ctime;			/* time of last change */
+  struct wait_queue *__unbounded __wwait; /* ??? */
+  struct wait_queue *__unbounded __rwait; /* ??? */
+  unsigned short int __msg_cbytes;	/* current number of bytes on queue */
+  unsigned short int msg_qnum;		/* number of messages currently on queue */
+  unsigned short int msg_qbytes;	/* max number of bytes allowed on queue */
+  __ipc_pid_t msg_lspid;		/* pid of last msgsnd() */
+  __ipc_pid_t msg_lrpid;		/* pid of last msgrcv() */
+};
+
+/* Allows to control internal state and destruction of message queue
+   objects.  */
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
+int __old_msgctl (int, int, struct __old_msqid_ds *);
+#endif
+int __new_msgctl (int, int, struct msqid_ds *);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
+int
+attribute_compat_text_section
+__old_msgctl (int msqid, int cmd, struct __old_msqid_ds *buf)
+{
+  return INLINE_SYSCALL (msgctl, 3, msqid, cmd, CHECK_1 (buf));
+}
+compat_symbol (libc, __old_msgctl, msgctl, GLIBC_2_0);
+#endif
+
+int
+__new_msgctl (int msqid, int cmd, struct msqid_ds *buf)
+{
+
+#if __ASSUME_IPC64 > 0
+  return INLINE_SYSCALL (msgctl, 3, msqid, cmd | __IPC_64, CHECK_1 (buf));
+#else
+  switch (cmd) {
+    case MSG_STAT:
+    case IPC_STAT:
+    case IPC_SET:
+      break;
+    default:
+      return INLINE_SYSCALL (msgctl, 3, msqid, cmd, CHECK_1 (buf));
+  }
+
+  {
+    int result;
+    struct __old_msqid_ds old;
+
+    /* Unfortunately there is no way how to find out for sure whether
+       we should use old or new msgctl.  */
+    result = INLINE_SYSCALL (msgctl, 3, msqid, cmd | __IPC_64, CHECK_1 (buf));
+    if (result != -1 || errno != EINVAL)
+      return result;
+
+    if (cmd == IPC_SET)
+      {
+	old.msg_perm.uid = buf->msg_perm.uid;
+	old.msg_perm.gid = buf->msg_perm.gid;
+	old.msg_perm.mode = buf->msg_perm.mode;
+	old.msg_qbytes = buf->msg_qbytes;
+	if (old.msg_perm.uid != buf->msg_perm.uid ||
+	    old.msg_perm.gid != buf->msg_perm.gid ||
+	    old.msg_qbytes != buf->msg_qbytes)
+	  {
+	    __set_errno (EINVAL);
+	    return -1;
+	  }
+      }
+    result = INLINE_SYSCALL (msgctl, 3, msqid, cmd, __ptrvalue (&old));
+    if (result != -1 && cmd != IPC_SET)
+      {
+	memset(buf, 0, sizeof(*buf));
+	buf->msg_perm.__key = old.msg_perm.__key;
+	buf->msg_perm.uid = old.msg_perm.uid;
+	buf->msg_perm.gid = old.msg_perm.gid;
+	buf->msg_perm.cuid = old.msg_perm.cuid;
+	buf->msg_perm.cgid = old.msg_perm.cgid;
+	buf->msg_perm.mode = old.msg_perm.mode;
+	buf->msg_perm.__seq = old.msg_perm.__seq;
+	buf->msg_stime = old.msg_stime;
+	buf->msg_rtime = old.msg_rtime;
+	buf->msg_ctime = old.msg_ctime;
+	buf->__msg_cbytes = old.__msg_cbytes;
+	buf->msg_qnum = old.msg_qnum;
+	buf->msg_qbytes = old.msg_qbytes;
+	buf->msg_lspid = old.msg_lspid;
+	buf->msg_lrpid = old.msg_lrpid;
+      }
+    return result;
+  }
+#endif
+}
+
+versioned_symbol (libc, __new_msgctl, msgctl, GLIBC_2_2);
diff --git a/sysdeps/unix/sysv/linux/microblaze/msgget.c b/sysdeps/unix/sysv/linux/microblaze/msgget.c
new file mode 100644
index 0000000..ac2b6fc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/msgget.c
@@ -0,0 +1,34 @@
+/* Copyright (C) 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/msg.h>
+#include <ipc_priv.h>
+#include <stdlib.h>		/* for definition of NULL */
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+/* Return descriptor for message queue associated with KEY.  The MSGFLG
+   parameter describes how to proceed with clashing of key values.  */
+
+int msgget (key_t key, int msgflg)
+{
+  return INLINE_SYSCALL (msgget, 2, key, msgflg);
+}
diff --git a/sysdeps/unix/sysv/linux/microblaze/msgrcv.c b/sysdeps/unix/sysv/linux/microblaze/msgrcv.c
new file mode 100644
index 0000000..ac5b34b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/msgrcv.c
@@ -0,0 +1,64 @@
+/* Copyright (C) 1995, 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/msg.h>
+#include <ipc_priv.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+
+#include <bp-checks.h>
+
+/* Kludge to work around Linux' restriction of only up to five
+   arguments to a system call.  */
+struct ipc_kludge
+  {
+    void *__unbounded msgp;
+    long int msgtyp;
+  };
+
+
+int
+__libc_msgrcv (msqid, msgp, msgsz, msgtyp, msgflg)
+     int msqid;
+     void *msgp;
+     size_t msgsz;
+     long int msgtyp;
+     int msgflg;
+{
+  /* The problem here is that Linux' calling convention only allows up to
+     fives parameters to a system call.  */
+  struct ipc_kludge tmp;
+
+  tmp.msgp = CHECK_N (msgp, msgsz);
+  tmp.msgtyp = msgtyp;
+
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (msgrcv, 5, msqid, CHECK_N (msgp, msgsz), msgsz, msgtyp, msgflg);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (msgrcv, 5, msqid, CHECK_N (msgp, msgsz), msgsz, msgtyp, msgflg);
+
+   LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+weak_alias (__libc_msgrcv, msgrcv)
diff --git a/sysdeps/unix/sysv/linux/microblaze/msgsnd.c b/sysdeps/unix/sysv/linux/microblaze/msgsnd.c
new file mode 100644
index 0000000..dcfb2d9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/msgsnd.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 1995,1997,1998,1999,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/msg.h>
+#include <ipc_priv.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+
+#include <bp-checks.h>
+
+int
+__libc_msgsnd (msqid, msgp, msgsz, msgflg)
+     int msqid;
+     const void *msgp;
+     size_t msgsz;
+     int msgflg;
+{
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (msgsnd, 4, msqid, (void *) CHECK_N (msgp, msgsz), msgsz, msgflg);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (msgsnd, 4, msqid, (void *) CHECK_N (msgp, msgsz), msgsz, msgflg);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+weak_alias (__libc_msgsnd, msgsnd)
diff --git a/sysdeps/unix/sysv/linux/microblaze/nptl/bits/atomic.h b/sysdeps/unix/sysv/linux/microblaze/nptl/bits/atomic.h
new file mode 100644
index 0000000..e106e24
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/nptl/bits/atomic.h
@@ -0,0 +1,63 @@
+/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdint.h>
+#include <sysdep.h>
+
+
+typedef int8_t atomic8_t;
+typedef uint8_t uatomic8_t;
+typedef int_fast8_t atomic_fast8_t;
+typedef uint_fast8_t uatomic_fast8_t;
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+void __microblaze_link_error (void);
+
+/* Atomic compare and exchange.  This sequence relies on the kernel to
+   provide a compare and exchange operation which is atomic on the
+   current architecture  */
+
+#define __arch_compare_and_exchange_val_8_acq(mem, newval, oldval) \
+  ({ __microblaze_link_error (); oldval; })
+
+#define __arch_compare_and_exchange_val_16_acq(mem, newval, oldval) \
+  ({ __microblaze_link_error (); oldval; })
+
+/* It doesn't matter what register is used for a_oldval2, but we must
+   specify one to work around GCC PR rtl-optimization/21223.  Otherwise
+   it may cause a_oldval or a_tmp to be moved to a different register.  */
+
+/* REVISIT: Not really atomic */
+/* REVISIT: Already defined in sysdeps/microblaze/bits/atomic.h */
+#define __arch_compare_and_exchange_val_32_acq(mem, newval, oldval)	\
+   ({ __typeof (*mem) result;						\
+      result = *mem;            					\
+      if (result == oldval) *mem = newval;            		\
+      result; })
+
+#define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \
+  ({ __microblaze_link_error (); oldval; })
diff --git a/sysdeps/unix/sysv/linux/microblaze/nptl/bits/pthreadtypes.h b/sysdeps/unix/sysv/linux/microblaze/nptl/bits/pthreadtypes.h
new file mode 100644
index 0000000..e1b115c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/nptl/bits/pthreadtypes.h
@@ -0,0 +1,181 @@
+/* Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#include <endian.h>
+
+#define __SIZEOF_PTHREAD_ATTR_T 36
+#define __SIZEOF_PTHREAD_MUTEX_T 24
+#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+#define __SIZEOF_PTHREAD_COND_T 48
+#define __SIZEOF_PTHREAD_COND_COMPAT_T 12
+#define __SIZEOF_PTHREAD_CONDATTR_T 4
+#define __SIZEOF_PTHREAD_RWLOCK_T 32
+#define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+#define __SIZEOF_PTHREAD_BARRIER_T 20
+#define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+
+
+/* Thread identifiers.  The structure of the attribute type is not
+   exposed on purpose.  */
+typedef unsigned long int pthread_t;
+
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_ATTR_T];
+  long int __align;
+} pthread_attr_t;
+
+
+typedef struct __pthread_internal_slist
+{
+  struct __pthread_internal_slist *__next;
+} __pthread_slist_t;
+
+
+/* Data structures for mutex handling.  The structure of the attribute
+   type is not exposed on purpose.  */
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+    /* KIND must stay at this position in the structure to maintain
+       binary compatibility.  */
+    int __kind;
+    unsigned int __nusers;
+    __extension__ union
+    {
+      int __spins;
+      __pthread_slist_t __list;
+    };
+  } __data;
+  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  long int __align;
+} pthread_mutex_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+  long int __align;
+} pthread_mutexattr_t;
+
+
+/* Data structure for conditional variable handling.  The structure of
+   the attribute type is not exposed on purpose.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_COND_T];
+  __extension__ long long int __align;
+} pthread_cond_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+  long int __align;
+} pthread_condattr_t;
+
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+/* Data structure for read-write lock variable handling.  The
+   structure of the attribute type is not exposed on purpose.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+#if __BYTE_ORDER == __BIG_ENDIAN
+    unsigned char __pad1;
+    unsigned char __pad2;
+    unsigned char __shared;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+#else
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+    unsigned char __shared;
+    unsigned char __pad1;
+    unsigned char __pad2;
+#endif
+    int __writer;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  long int __align;
+} pthread_rwlock_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+  long int __align;
+} pthread_rwlockattr_t;
+#endif
+
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+typedef volatile int pthread_spinlock_t;
+
+
+/* POSIX barriers data type.  The structure of the type is
+   deliberately not exposed.  */
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+  long int __align;
+} pthread_barrier_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+  int __align;
+} pthread_barrierattr_t;
+#endif
+
+
+#endif	/* bits/pthreadtypes.h */
diff --git a/sysdeps/unix/sysv/linux/microblaze/nptl/bits/semaphore.h b/sysdeps/unix/sysv/linux/microblaze/nptl/bits/semaphore.h
new file mode 100644
index 0000000..dadfac2
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/nptl/bits/semaphore.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 2002, 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+
+#define __SIZEOF_SEM_T	16
+
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
diff --git a/sysdeps/unix/sysv/linux/microblaze/nptl/fork.c b/sysdeps/unix/sysv/linux/microblaze/nptl/fork.c
new file mode 100644
index 0000000..d31889e
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/nptl/fork.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fork.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/nptl/lowlevellock.h b/sysdeps/unix/sysv/linux/microblaze/nptl/lowlevellock.h
new file mode 100644
index 0000000..f83294f
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/nptl/lowlevellock.h
@@ -0,0 +1,283 @@
+/* Copyright (C) 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LOWLEVELLOCK_H
+#define _LOWLEVELLOCK_H	1
+
+#include <time.h>
+#include <sys/param.h>
+#include <bits/pthreadtypes.h>
+#include <atomic.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include <tls.h>		/* Need THREAD_*, and header.*.  */
+
+#define FUTEX_WAIT		0
+#define FUTEX_WAKE		1
+#define FUTEX_REQUEUE		3
+#define FUTEX_CMP_REQUEUE	4
+#define FUTEX_WAKE_OP		5
+#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE	((4 << 24) | 1)
+#define FUTEX_LOCK_PI		6
+#define FUTEX_UNLOCK_PI		7
+#define FUTEX_TRYLOCK_PI	8
+#define FUTEX_WAIT_BITSET	9
+#define FUTEX_WAKE_BITSET	10
+#define FUTEX_PRIVATE_FLAG	128
+#define FUTEX_CLOCK_REALTIME	256
+
+#define FUTEX_BITSET_MATCH_ANY	0xffffffff
+
+/* Values for 'private' parameter of locking macros.  Yes, the
+   definition seems to be backwards.  But it is not.  The bit will be
+   reversed before passing to the system call.  */
+#define LLL_PRIVATE	0
+#define LLL_SHARED	FUTEX_PRIVATE_FLAG
+
+
+#if !defined NOT_IN_libc || defined IS_IN_rtld
+/* In libc.so or ld.so all futexes are private.  */
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  ((fl) | FUTEX_PRIVATE_FLAG)
+# else
+#  define __lll_private_flag(fl, private) \
+  ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))
+# endif
+#else
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  (((fl) | FUTEX_PRIVATE_FLAG) ^ (private))
+# else
+#  define __lll_private_flag(fl, private) \
+  (__builtin_constant_p (private)					      \
+   ? ((private) == 0							      \
+      ? ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))	      \
+      : (fl))								      \
+   : ((fl) | (((private) ^ FUTEX_PRIVATE_FLAG)				      \
+	      & THREAD_GETMEM (THREAD_SELF, header.private_futex))))
+# endif
+#endif
+
+
+#define lll_futex_wait(futexp, val, private) \
+  lll_futex_timed_wait(futexp, val, NULL, private)
+
+#define lll_futex_timed_wait(futexp, val, timespec, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAIT, private),	      \
+			      (val), (timespec));			      \
+    __ret;								      \
+  })
+
+#define lll_futex_wake(futexp, nr, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE, private),	      \
+			      (nr), 0);					      \
+    __ret;								      \
+  })
+
+#define lll_robust_dead(futexv, private) \
+  do									      \
+    {									      \
+      int *__futexp = &(futexv);					      \
+      atomic_or (__futexp, FUTEX_OWNER_DIED);				      \
+      lll_futex_wake (__futexp, 1, private);				      \
+    }									      \
+  while (0)
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_requeue(futexp, nr_wake, nr_move, mutex, val, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_CMP_REQUEUE, private),\
+			      (nr_wake), (nr_move), (mutex), (val));	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_wake_unlock(futexp, nr_wake, nr_wake2, futexp2, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE_OP, private),    \
+			      (nr_wake), (nr_wake2), (futexp2),		      \
+			      FUTEX_OP_CLEAR_WAKE_IF_GT_ONE);		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+
+#define lll_trylock(lock)	\
+  atomic_compare_and_exchange_val_acq(&(lock), 1, 0)
+
+#define lll_cond_trylock(lock)	\
+  atomic_compare_and_exchange_val_acq(&(lock), 2, 0)
+
+#define __lll_robust_trylock(futex, id) \
+  (atomic_compare_and_exchange_val_acq (futex, id, 0) != 0)
+#define lll_robust_trylock(lock, id) \
+  __lll_robust_trylock (&(lock), id)
+
+extern void __lll_lock_wait_private (int *futex) attribute_hidden;
+extern void __lll_lock_wait (int *futex, int private) attribute_hidden;
+extern int __lll_robust_lock_wait (int *futex, int private) attribute_hidden;
+
+#define __lll_lock(futex, private)					      \
+  ((void) ({								      \
+    int *__futex = (futex);						      \
+    if (__builtin_expect (atomic_compare_and_exchange_val_acq (__futex,       \
+								1, 0), 0))    \
+      {									      \
+	if (__builtin_constant_p (private) && (private) == LLL_PRIVATE)	      \
+	  __lll_lock_wait_private (__futex);				      \
+	else								      \
+	  __lll_lock_wait (__futex, private);				      \
+      }									      \
+  }))
+#define lll_lock(futex, private) __lll_lock (&(futex), private)
+
+
+#define __lll_robust_lock(futex, id, private)				      \
+  ({									      \
+    int *__futex = (futex);						      \
+    int __val = 0;							      \
+									      \
+    if (__builtin_expect (atomic_compare_and_exchange_bool_acq (__futex, id,  \
+								0), 0))	      \
+      __val = __lll_robust_lock_wait (__futex, private);		      \
+    __val;								      \
+  })
+#define lll_robust_lock(futex, id, private) \
+  __lll_robust_lock (&(futex), id, private)
+
+
+#define __lll_cond_lock(futex, private)					      \
+  ((void) ({								      \
+    int *__futex = (futex);						      \
+    if (__builtin_expect (atomic_exchange_acq (__futex, 2), 0))		      \
+      __lll_lock_wait (__futex, private);				      \
+  }))
+#define lll_cond_lock(futex, private) __lll_cond_lock (&(futex), private)
+
+
+#define lll_robust_cond_lock(futex, id, private) \
+  __lll_robust_lock (&(futex), (id) | FUTEX_WAITERS, private)
+
+
+extern int __lll_timedlock_wait (int *futex, const struct timespec *,
+				 int private) attribute_hidden;
+extern int __lll_robust_timedlock_wait (int *futex, const struct timespec *,
+					int private) attribute_hidden;
+
+#define __lll_timedlock(futex, abstime, private)			      \
+  ({									      \
+     int *__futex = (futex);						      \
+     int __val = 0;							      \
+									      \
+     if (__builtin_expect (atomic_exchange_acq (__futex, 1), 0))	      \
+       __val = __lll_timedlock_wait (__futex, abstime, private);	      \
+     __val;								      \
+  })
+#define lll_timedlock(futex, abstime, private) \
+  __lll_timedlock (&(futex), abstime, private)
+
+
+#define __lll_robust_timedlock(futex, abstime, id, private)		      \
+  ({									      \
+    int *__futex = (futex);						      \
+    int __val = 0;							      \
+									      \
+    if (__builtin_expect (atomic_compare_and_exchange_bool_acq (__futex, id,  \
+								0), 0))	      \
+      __val = __lll_robust_timedlock_wait (__futex, abstime, private);	      \
+    __val;								      \
+  })
+#define lll_robust_timedlock(futex, abstime, id, private) \
+  __lll_robust_timedlock (&(futex), abstime, id, private)
+
+
+#define __lll_unlock(futex, private) \
+  (void)							\
+    ({ int *__futex = (futex);					\
+       int __oldval = atomic_exchange_rel (__futex, 0);		\
+       if (__builtin_expect (__oldval > 1, 0))			\
+	 lll_futex_wake (__futex, 1, private);			\
+    })
+#define lll_unlock(futex, private) __lll_unlock(&(futex), private)
+
+
+#define __lll_robust_unlock(futex, private) \
+  (void)							\
+    ({ int *__futex = (futex);					\
+       int __oldval = atomic_exchange_rel (__futex, 0);		\
+       if (__builtin_expect (__oldval & FUTEX_WAITERS, 0))	\
+	 lll_futex_wake (__futex, 1, private);			\
+    })
+#define lll_robust_unlock(futex, private) \
+  __lll_robust_unlock(&(futex), private)
+
+
+#define lll_islocked(futex) \
+  (futex != 0)
+
+
+/* Our internal lock implementation is identical to the binary-compatible
+   mutex implementation. */
+
+/* Initializers for lock.  */
+#define LLL_LOCK_INITIALIZER		(0)
+#define LLL_LOCK_INITIALIZER_LOCKED	(1)
+
+/* The states of a lock are:
+    0  -  untaken
+    1  -  taken by one user
+   >1  -  taken by more users */
+
+/* The kernel notifies a process which uses CLONE_CLEARTID via futex
+   wakeup when the clone terminates.  The memory location contains the
+   thread ID while the clone is running and is reset to zero
+   afterwards.	*/
+#define lll_wait_tid(tid) \
+  do {					\
+    __typeof (tid) __tid;		\
+    while ((__tid = (tid)) != 0)	\
+      lll_futex_wait (&(tid), __tid, LLL_SHARED);\
+  } while (0)
+
+extern int __lll_timedwait_tid (int *, const struct timespec *)
+     attribute_hidden;
+
+#define lll_timedwait_tid(tid, abstime) \
+  ({							\
+    int __res = 0;					\
+    if ((tid) != 0)					\
+      __res = __lll_timedwait_tid (&(tid), (abstime));	\
+    __res;						\
+  })
+
+#endif	/* lowlevellock.h */
diff --git a/sysdeps/unix/sysv/linux/microblaze/nptl/pt-vfork.S b/sysdeps/unix/sysv/linux/microblaze/nptl/pt-vfork.S
new file mode 100644
index 0000000..fffed89
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/nptl/pt-vfork.S
@@ -0,0 +1,21 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tcb-offsets.h>
+
+#include "../vfork.S"
diff --git a/sysdeps/unix/sysv/linux/microblaze/nptl/pthread_once.c b/sysdeps/unix/sysv/linux/microblaze/nptl/pthread_once.c
new file mode 100644
index 0000000..ddfd32b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/nptl/pthread_once.c
@@ -0,0 +1,94 @@
+/* Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+#include <lowlevellock.h>
+
+
+unsigned long int __fork_generation attribute_hidden;
+
+
+static void
+clear_once_control (void *arg)
+{
+  pthread_once_t *once_control = (pthread_once_t *) arg;
+
+  *once_control = 0;
+  lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
+}
+
+
+int
+__pthread_once (once_control, init_routine)
+     pthread_once_t *once_control;
+     void (*init_routine) (void);
+{
+  while (1)
+    {
+      int oldval, val, newval;
+
+      val = *once_control;
+      do
+	{
+	  /* Check if the initialized has already been done.  */
+	  if ((val & 2) != 0)
+	    return 0;
+
+	  oldval = val;
+	  newval = (oldval & 3) | __fork_generation | 1;
+	  val = atomic_compare_and_exchange_val_acq (once_control, newval,
+						     oldval);
+	}
+      while (__builtin_expect (val != oldval, 0));
+
+      /* Check if another thread already runs the initializer.	*/
+      if ((oldval & 1) != 0)
+	{
+	  /* Check whether the initializer execution was interrupted
+	     by a fork.	 */
+	  if (((oldval ^ newval) & -4) == 0)
+	    {
+	      /* Same generation, some other thread was faster. Wait.  */
+	      lll_futex_wait (once_control, newval, LLL_PRIVATE);
+	      continue;
+	    }
+	}
+
+      /* This thread is the first here.  Do the initialization.
+	 Register a cleanup handler so that in case the thread gets
+	 interrupted the initialization can be restarted.  */
+      pthread_cleanup_push (clear_once_control, once_control);
+
+      init_routine ();
+
+      pthread_cleanup_pop (0);
+
+
+      /* Add one to *once_control.  */
+      atomic_increment (once_control);
+
+      /* Wake up all other threads.  */
+      lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
+      break;
+    }
+
+  return 0;
+}
+weak_alias (__pthread_once, pthread_once)
+strong_alias (__pthread_once, __pthread_once_internal)
diff --git a/sysdeps/unix/sysv/linux/microblaze/nptl/unwind-forcedunwind.c b/sysdeps/unix/sysv/linux/microblaze/nptl/unwind-forcedunwind.c
new file mode 100644
index 0000000..e19facf
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/nptl/unwind-forcedunwind.c
@@ -0,0 +1,146 @@
+/* Copyright (C) 2003, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <dlfcn.h>
+#include <stdio.h>
+#include <unwind.h>
+#include <pthreadP.h>
+
+static void *libgcc_s_handle;
+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);
+static _Unwind_Reason_Code (*libgcc_s_personality)
+  (int, _Unwind_Action, _Unwind_Exception_Class, struct _Unwind_Exception *,
+   struct _Unwind_Context *);
+static _Unwind_Reason_Code (*libgcc_s_forcedunwind)
+  (struct _Unwind_Exception *, _Unwind_Stop_Fn, void *);
+static _Unwind_Word (*libgcc_s_getcfa) (struct _Unwind_Context *);
+static void (*libgcc_s_sjlj_register) (struct SjLj_Function_Context *);
+static void (*libgcc_s_sjlj_unregister) (struct SjLj_Function_Context *);
+
+void
+__attribute_noinline__
+pthread_cancel_init (void)
+{
+  void *resume, *personality, *forcedunwind, *getcfa;
+  void *handle;
+  void *sjlj_register, *sjlj_unregister;
+
+  if (__builtin_expect (libgcc_s_handle != NULL, 1))
+    {
+      /* Force gcc to reload all values.  */
+      asm volatile ("" ::: "memory");
+      return;
+    }
+
+  handle = __libc_dlopen ("libgcc_s.so.1");
+
+  if (handle == NULL
+      || (sjlj_register = __libc_dlsym (handle, "_Unwind_SjLj_Register")) == NULL
+      || (sjlj_unregister = __libc_dlsym (handle, "_Unwind_SjLj_Unregister")) == NULL
+      || (resume = __libc_dlsym (handle, "_Unwind_SjLj_Resume")) == NULL
+      || (personality = __libc_dlsym (handle, "__gcc_personality_sj0")) == NULL
+      || (forcedunwind = __libc_dlsym (handle, "_Unwind_SjLj_ForcedUnwind"))
+	 == NULL
+      || (getcfa = __libc_dlsym (handle, "_Unwind_GetCFA")) == NULL
+      )
+    __libc_fatal ("libgcc_s.so.1 must be installed for pthread_cancel to work\n");
+
+  libgcc_s_resume = resume;
+  libgcc_s_personality = personality;
+  libgcc_s_forcedunwind = forcedunwind;
+  libgcc_s_sjlj_register = sjlj_register;
+  libgcc_s_sjlj_unregister = sjlj_unregister;
+  libgcc_s_getcfa = getcfa;
+  /* Make sure libgcc_s_getcfa is written last.  Otherwise,
+     pthread_cancel_init might return early even when the pointer the
+     caller is interested in is not initialized yet.  */
+  atomic_write_barrier ();
+  libgcc_s_handle = handle;
+}
+
+void
+__libc_freeres_fn_section
+__unwind_freeres (void)
+{
+  void *handle = libgcc_s_handle;
+  if (handle != NULL)
+    {
+      libgcc_s_handle = NULL;
+      __libc_dlclose (handle);
+    }
+}
+
+void
+_Unwind_Resume (struct _Unwind_Exception *exc)
+{
+  if (__builtin_expect (libgcc_s_resume == NULL, 0))
+    pthread_cancel_init ();
+
+  libgcc_s_resume (exc);
+}
+
+_Unwind_Reason_Code
+__gcc_personality_v0 (int version, _Unwind_Action actions,
+		      _Unwind_Exception_Class exception_class,
+                      struct _Unwind_Exception *ue_header,
+                      struct _Unwind_Context *context)
+{
+  if (__builtin_expect (libgcc_s_personality == NULL, 0))
+    pthread_cancel_init ();
+
+  return libgcc_s_personality (version, actions, exception_class,
+			       ue_header, context);
+}
+
+_Unwind_Reason_Code
+_Unwind_ForcedUnwind (struct _Unwind_Exception *exc, _Unwind_Stop_Fn stop,
+		      void *stop_argument)
+{
+  if (__builtin_expect (libgcc_s_forcedunwind == NULL, 0))
+    pthread_cancel_init ();
+
+  return libgcc_s_forcedunwind (exc, stop, stop_argument);
+}
+
+_Unwind_Word
+_Unwind_GetCFA (struct _Unwind_Context *context)
+{
+  if (__builtin_expect (libgcc_s_getcfa == NULL, 0))
+    pthread_cancel_init ();
+
+  return libgcc_s_getcfa (context);
+}
+
+void
+_Unwind_SjLj_Register (struct SjLj_Function_Context *fc)
+{
+  if (__builtin_expect (libgcc_s_sjlj_register == NULL, 0))
+    pthread_cancel_init ();
+
+  libgcc_s_sjlj_register (fc);
+}
+
+void
+_Unwind_SjLj_Unregister (struct SjLj_Function_Context *fc)
+{
+  if (__builtin_expect (libgcc_s_sjlj_unregister == NULL, 0))
+    pthread_cancel_init ();
+
+  libgcc_s_sjlj_unregister (fc);
+}
diff --git a/sysdeps/unix/sysv/linux/microblaze/nptl/unwind-resume.c b/sysdeps/unix/sysv/linux/microblaze/nptl/unwind-resume.c
new file mode 100644
index 0000000..8dcfd34
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/nptl/unwind-resume.c
@@ -0,0 +1,87 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <dlfcn.h>
+#include <stdio.h>
+#include <unwind.h>
+
+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);
+static _Unwind_Reason_Code (*libgcc_s_personality)
+  (int, _Unwind_Action, _Unwind_Exception_Class, struct _Unwind_Exception *,
+   struct _Unwind_Context *);
+static void (*libgcc_s_sjlj_register) (struct SjLj_Function_Context *);
+static void (*libgcc_s_sjlj_unregister) (struct SjLj_Function_Context *);
+
+static void
+init (void)
+{
+  void *resume, *personality;
+  void *handle;
+  void *sjlj_register, *sjlj_unregister;
+
+  handle = __libc_dlopen ("libgcc_s.so.1");
+
+  if (handle == NULL
+      || (sjlj_register = __libc_dlsym (handle, "_Unwind_SjLj_Register")) == NULL
+      || (sjlj_unregister = __libc_dlsym (handle, "_Unwind_SjLj_Unregister")) == NULL
+      || (resume = __libc_dlsym (handle, "_Unwind_SjLj_Resume")) == NULL
+      || (personality = __libc_dlsym (handle, "__gcc_personality_sj0")) == NULL)
+    __libc_fatal ("libgcc_s.so.1 must be installed for pthread_cancel to work\n");
+
+  libgcc_s_resume = resume;
+  libgcc_s_personality = personality;
+  libgcc_s_sjlj_register = sjlj_register;
+  libgcc_s_sjlj_unregister = sjlj_unregister;
+}
+
+void
+_Unwind_Resume (struct _Unwind_Exception *exc)
+{
+  if (__builtin_expect (libgcc_s_resume == NULL, 0))
+    init ();
+  libgcc_s_resume (exc);
+}
+
+_Unwind_Reason_Code
+__gcc_personality_v0 (int version, _Unwind_Action actions,
+		      _Unwind_Exception_Class exception_class,
+                      struct _Unwind_Exception *ue_header,
+                      struct _Unwind_Context *context)
+{
+  if (__builtin_expect (libgcc_s_personality == NULL, 0))
+    init ();
+  return libgcc_s_personality (version, actions, exception_class,
+			       ue_header, context);
+}
+
+void
+_Unwind_SjLj_Register (struct SjLj_Function_Context *fc)
+{
+  if (__builtin_expect (libgcc_s_sjlj_register == NULL, 0))
+    init ();
+  libgcc_s_sjlj_register (fc);
+}
+
+void
+_Unwind_SjLj_Unregister (struct SjLj_Function_Context *fc)
+{
+  if (__builtin_expect (libgcc_s_sjlj_unregister == NULL, 0))
+    init ();
+  libgcc_s_sjlj_unregister (fc);
+}
diff --git a/sysdeps/unix/sysv/linux/microblaze/nptl/unwind.h b/sysdeps/unix/sysv/linux/microblaze/nptl/unwind.h
new file mode 100644
index 0000000..8dd834e
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/nptl/unwind.h
@@ -0,0 +1,31 @@
+/* Exception handling and frame unwind runtime interface routines.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _ARM_UNWIND_H
+#define _ARM_UNWIND_H	1
+
+#include <sysdeps/generic/unwind.h>
+
+/* Call the SjLj versions of these functions.  */
+#define _Unwind_ForcedUnwind _Unwind_SjLj_ForcedUnwind
+#define _Unwind_Resume _Unwind_SjLj_Resume
+#define __gcc_personality_v0 __gcc_personality_sj0
+
+#endif	/* unwind.h */
diff --git a/sysdeps/unix/sysv/linux/microblaze/oldgetrlimit64.c b/sysdeps/unix/sysv/linux/microblaze/oldgetrlimit64.c
new file mode 100644
index 0000000..4c27e95
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/oldgetrlimit64.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/oldgetrlimit64.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/profil-counter.h b/sysdeps/unix/sysv/linux/microblaze/profil-counter.h
new file mode 100644
index 0000000..8a6a0bc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/profil-counter.h
@@ -0,0 +1,2 @@
+/* We can use the ix86 version.  */
+#include <sysdeps/unix/sysv/linux/i386/profil-counter.h>
diff --git a/sysdeps/unix/sysv/linux/microblaze/putmsg.c b/sysdeps/unix/sysv/linux/microblaze/putmsg.c
new file mode 100644
index 0000000..ebc1680
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/putmsg.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/putmsg.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/readdir64.c b/sysdeps/unix/sysv/linux/microblaze/readdir64.c
new file mode 100644
index 0000000..2ea26dd
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/readdir64.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/readdir64.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/readdir64_r.c b/sysdeps/unix/sysv/linux/microblaze/readdir64_r.c
new file mode 100644
index 0000000..9f54f89
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/readdir64_r.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/readdir64_r.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/register-dump.h b/sysdeps/unix/sysv/linux/microblaze/register-dump.h
new file mode 100644
index 0000000..b3ac268
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/register-dump.h
@@ -0,0 +1,20 @@
+/* Dump registers.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <sys/uio.h>
+#include <stdio-common/_itoa.h>
diff --git a/sysdeps/unix/sysv/linux/microblaze/scandir64.c b/sysdeps/unix/sysv/linux/microblaze/scandir64.c
new file mode 100644
index 0000000..506fd88
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/scandir64.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/scandir64.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/semctl.c b/sysdeps/unix/sysv/linux/microblaze/semctl.c
new file mode 100644
index 0000000..2f92337
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/semctl.c
@@ -0,0 +1,191 @@
+/* Copyright (C) 1995, 1997, 1998, 2000, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stdarg.h>
+#include <sys/sem.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <string.h>
+#include <sys/syscall.h>
+#include <shlib-compat.h>
+
+#include "kernel-features.h"
+
+struct __old_semid_ds
+{
+  struct __old_ipc_perm sem_perm;	/* operation permission struct */
+  __time_t sem_otime;			/* last semop() time */
+  __time_t sem_ctime;			/* last time changed by semctl() */
+  struct sem *__unbounded __sembase;	/* ptr to first semaphore in array */
+  struct sem_queue *__unbounded __sem_pending; /* pending operations */
+  struct sem_queue *__unbounded __sem_pending_last; /* last pending operation */
+  struct sem_undo *__unbounded __undo;	/* ondo requests on this array */
+  unsigned short int sem_nsems;		/* number of semaphores in set */
+};
+
+/* Define a `union semun' suitable for Linux here.  */
+union semun
+{
+  int val;			/* value for SETVAL */
+  struct semid_ds *buf;		/* buffer for IPC_STAT & IPC_SET */
+  unsigned short int *array;	/* array for GETALL & SETALL */
+  struct seminfo *__buf;	/* buffer for IPC_INFO */
+  struct __old_semid_ds *__old_buf;
+};
+
+#include <bp-checks.h>
+#include <bp-semctl.h>		/* definition of CHECK_SEMCTL needs union semum */
+
+/* Return identifier for array of NSEMS semaphores associated with
+   KEY.  */
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
+int __old_semctl (int semid, int semnum, int cmd, ...);
+#endif
+int __new_semctl (int semid, int semnum, int cmd, ...);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
+int
+attribute_compat_text_section
+__old_semctl (int semid, int semnum, int cmd, ...)
+{
+  union semun arg;
+  va_list ap;
+
+  va_start (ap, cmd);
+
+  /* Get the argument only if required.  */
+  arg.buf = NULL;
+  switch (cmd)
+    {
+    case SETVAL:        /* arg.val */
+    case GETALL:        /* arg.array */
+    case SETALL:
+    case IPC_STAT:      /* arg.buf */
+    case IPC_SET:
+    case SEM_STAT:
+    case IPC_INFO:      /* arg.__buf */
+    case SEM_INFO:
+      va_start (ap, cmd);
+      arg = va_arg (ap, union semun);
+      va_end (ap);
+      break;
+    }
+
+  va_end (ap);
+
+  return INLINE_SYSCALL (semctl, 4, semid, semnum, cmd, CHECK_SEMCTL (&arg, semid, cmd)->array);
+}
+compat_symbol (libc, __old_semctl, semctl, GLIBC_2_0);
+#endif
+
+int
+__new_semctl (int semid, int semnum, int cmd, ...)
+{
+  union semun arg;
+  va_list ap;
+
+  va_start (ap, cmd);
+
+  /* Get the argument only if required.  */
+  arg.buf = NULL;
+  switch (cmd)
+    {
+    case SETVAL:        /* arg.val */
+    case GETALL:        /* arg.array */
+    case SETALL:
+    case IPC_STAT:      /* arg.buf */
+    case IPC_SET:
+    case SEM_STAT:
+    case IPC_INFO:      /* arg.__buf */
+    case SEM_INFO:
+      va_start (ap, cmd);
+      arg = va_arg (ap, union semun);
+      va_end (ap);
+      break;
+    }
+
+  va_end (ap);
+
+#if __ASSUME_IPC64 > 0
+  return INLINE_SYSCALL (semctl, 4, semid, semnum, cmd | __IPC_64,
+			 CHECK_SEMCTL (&arg, semid, cmd | __IPC_64)->array);
+#else
+  switch (cmd)
+    {
+    case SEM_STAT:
+    case IPC_STAT:
+    case IPC_SET:
+      break;
+    default:
+      return INLINE_SYSCALL (semctl, 4, semid, semnum, cmd,
+			     CHECK_SEMCTL (&arg, semid, cmd)->array);
+    }
+
+  {
+    int save_errno = errno, result;
+    struct __old_semid_ds old;
+    struct semid_ds *buf;
+
+    /* Unfortunately there is no way how to find out for sure whether
+       we should use old or new semctl.  */
+    result = INLINE_SYSCALL (semctl, 4, semid, semnum, cmd | __IPC_64,
+			     CHECK_SEMCTL (&arg, semid, cmd | __IPC_64)->array);
+    if (result != -1 || errno != EINVAL)
+      return result;
+
+    __set_errno(save_errno);
+    buf = arg.buf;
+    arg.__old_buf = &old;
+    if (cmd == IPC_SET)
+      {
+	old.sem_perm.uid = buf->sem_perm.uid;
+	old.sem_perm.gid = buf->sem_perm.gid;
+	old.sem_perm.mode = buf->sem_perm.mode;
+	if (old.sem_perm.uid != buf->sem_perm.uid ||
+	    old.sem_perm.gid != buf->sem_perm.gid)
+	  {
+	    __set_errno (EINVAL);
+	    return -1;
+	  }
+      }
+    result = INLINE_SYSCALL (semctl, 4, semid, semnum, cmd,
+			     CHECK_SEMCTL (&arg, semid, cmd)->array);
+    if (result != -1 && cmd != IPC_SET)
+      {
+	memset(buf, 0, sizeof(*buf));
+	buf->sem_perm.__key = old.sem_perm.__key;
+	buf->sem_perm.uid = old.sem_perm.uid;
+	buf->sem_perm.gid = old.sem_perm.gid;
+	buf->sem_perm.cuid = old.sem_perm.cuid;
+	buf->sem_perm.cgid = old.sem_perm.cgid;
+	buf->sem_perm.mode = old.sem_perm.mode;
+	buf->sem_perm.__seq = old.sem_perm.__seq;
+	buf->sem_otime = old.sem_otime;
+	buf->sem_ctime = old.sem_ctime;
+	buf->sem_nsems = old.sem_nsems;
+      }
+    return result;
+  }
+#endif
+}
+
+versioned_symbol (libc, __new_semctl, semctl, GLIBC_2_2);
diff --git a/sysdeps/unix/sysv/linux/microblaze/semget.c b/sysdeps/unix/sysv/linux/microblaze/semget.c
new file mode 100644
index 0000000..1a990af
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/semget.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/sem.h>
+#include <ipc_priv.h>
+#include <stdlib.h>		/* for definition of NULL */
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+/* Return identifier for array of NSEMS semaphores associated with
+   KEY.  */
+
+int
+semget (key, nsems, semflg)
+     key_t key;
+     int nsems;
+     int semflg;
+{
+  return INLINE_SYSCALL (semget, 3, key, nsems, semflg);
+}
diff --git a/sysdeps/unix/sysv/linux/microblaze/semop.c b/sysdeps/unix/sysv/linux/microblaze/semop.c
new file mode 100644
index 0000000..31b7f1d
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/semop.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 1995, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/sem.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+/* Perform user-defined atomical operation of array of semaphores.  */
+
+int
+semop (semid, sops, nsops)
+     int semid;
+     struct sembuf *sops;
+     size_t nsops;
+{
+  return INLINE_SYSCALL (semop, 3, semid, CHECK_N (sops, nsops), (int) nsops);
+}
diff --git a/sysdeps/unix/sysv/linux/microblaze/setegid.c b/sysdeps/unix/sysv/linux/microblaze/setegid.c
new file mode 100644
index 0000000..2e3a54c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/setegid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setegid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/seteuid.c b/sysdeps/unix/sysv/linux/microblaze/seteuid.c
new file mode 100644
index 0000000..18e41d0
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/seteuid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/seteuid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/setfsgid.c b/sysdeps/unix/sysv/linux/microblaze/setfsgid.c
new file mode 100644
index 0000000..0886712
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/setfsgid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setfsgid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/setfsuid.c b/sysdeps/unix/sysv/linux/microblaze/setfsuid.c
new file mode 100644
index 0000000..a9f22eb
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/setfsuid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setfsuid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/setgid.c b/sysdeps/unix/sysv/linux/microblaze/setgid.c
new file mode 100644
index 0000000..377021d
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/setgid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setgid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/setgroups.c b/sysdeps/unix/sysv/linux/microblaze/setgroups.c
new file mode 100644
index 0000000..0e70862
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/setgroups.c
@@ -0,0 +1,2 @@
+/* We also have to rewrite the kernel gid_t to the user land type.  */
+#include <sysdeps/unix/sysv/linux/i386/setgroups.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/setregid.c b/sysdeps/unix/sysv/linux/microblaze/setregid.c
new file mode 100644
index 0000000..99c57ad
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/setregid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setregid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/setresgid.c b/sysdeps/unix/sysv/linux/microblaze/setresgid.c
new file mode 100644
index 0000000..daca1a4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/setresgid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setresgid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/setresuid.c b/sysdeps/unix/sysv/linux/microblaze/setresuid.c
new file mode 100644
index 0000000..3aeabe9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/setresuid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setresuid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/setreuid.c b/sysdeps/unix/sysv/linux/microblaze/setreuid.c
new file mode 100644
index 0000000..8ad6122
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/setreuid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setreuid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/setrlimit.c b/sysdeps/unix/sysv/linux/microblaze/setrlimit.c
new file mode 100644
index 0000000..bfaef74
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/setrlimit.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setrlimit.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/setuid.c b/sysdeps/unix/sysv/linux/microblaze/setuid.c
new file mode 100644
index 0000000..de39437
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/setuid.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setuid.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/shmat.c b/sysdeps/unix/sysv/linux/microblaze/shmat.c
new file mode 100644
index 0000000..e429015
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/shmat.c
@@ -0,0 +1,56 @@
+/* Copyright (C) 1995,1997,1998,1999,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/shm.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+/* Attach the shared memory segment associated with SHMID to the data
+   segment of the calling process.  SHMADDR and SHMFLG determine how
+   and where the segment is attached.  */
+
+void *
+shmat (shmid, shmaddr, shmflg)
+     int shmid;
+     const void *shmaddr;
+     int shmflg;
+{
+  void *__unbounded result;
+  void *__unbounded raddr;
+
+#if __BOUNDED_POINTERS__
+  size_t length = ~0;
+  struct shmid_ds shmds;
+  /* It's unfortunate that we need to make another system call to get
+     the shared memory segment length...  */
+  if (shmctl (shmid, IPC_STAT, &shmds) == 0)
+    length = shmds.shm_segsz;
+#endif
+
+  result = (void *__unbounded) INLINE_SYSCALL (shmat, 3, shmid, __ptrvalue ((void *) shmaddr), shmflg);
+  if ((unsigned long) result <= -(unsigned long) SHMLBA)
+    result = raddr;
+
+  return BOUNDED_N (result, length);
+}
diff --git a/sysdeps/unix/sysv/linux/microblaze/shmctl.c b/sysdeps/unix/sysv/linux/microblaze/shmctl.c
new file mode 100644
index 0000000..66881df
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/shmctl.c
@@ -0,0 +1,156 @@
+/* Copyright (C) 1995, 1997, 1998, 2000, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/shm.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <string.h>
+#include <sys/syscall.h>
+#include <bits/wordsize.h>
+#include <shlib-compat.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+struct __old_shmid_ds
+{
+  struct __old_ipc_perm shm_perm;	/* operation permission struct */
+  int shm_segsz;			/* size of segment in bytes */
+  __time_t shm_atime;			/* time of last shmat() */
+  __time_t shm_dtime;			/* time of last shmdt() */
+  __time_t shm_ctime;			/* time of last change by shmctl() */
+  __ipc_pid_t shm_cpid;			/* pid of creator */
+  __ipc_pid_t shm_lpid;			/* pid of last shmop */
+  unsigned short int shm_nattch;	/* number of current attaches */
+  unsigned short int __shm_npages;	/* size of segment (pages) */
+  unsigned long int *__unbounded __shm_pages; /* array of ptrs to frames -> SHMMAX */
+  struct vm_area_struct *__unbounded __attaches; /* descriptors for attaches */
+};
+
+struct __old_shminfo
+{
+  int shmmax;
+  int shmmin;
+  int shmmni;
+  int shmseg;
+  int shmall;
+};
+
+/* Provide operations to control over shared memory segments.  */
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
+int __old_shmctl (int, int, struct __old_shmid_ds *);
+#endif
+int __new_shmctl (int, int, struct shmid_ds *);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_2)
+int
+attribute_compat_text_section
+__old_shmctl (int shmid, int cmd, struct __old_shmid_ds *buf)
+{
+  return INLINE_SYSCALL (shmctl, 3, shmid, cmd, CHECK_1_NULL_OK (buf));
+}
+compat_symbol (libc, __old_shmctl, shmctl, GLIBC_2_0);
+#endif
+
+int
+__new_shmctl (int shmid, int cmd, struct shmid_ds *buf)
+{
+#if __ASSUME_IPC64 > 0
+  return INLINE_SYSCALL (shmctl, 3, shmid, cmd | __IPC_64, CHECK_1 (buf));
+#else
+  switch (cmd) {
+    case SHM_STAT:
+    case IPC_STAT:
+    case IPC_SET:
+#if __WORDSIZE != 32
+    case IPC_INFO:
+#endif
+      break;
+    default:
+      return INLINE_SYSCALL (shmctl, 3, shmid, cmd, CHECK_1 (buf));
+  }
+
+  {
+    int save_errno = errno, result;
+    union
+      {
+	struct __old_shmid_ds ds;
+	struct __old_shminfo info;
+      } old;
+
+    /* Unfortunately there is no way how to find out for sure whether
+       we should use old or new shmctl.  */
+    result = INLINE_SYSCALL (shmctl, 3, shmid, cmd | __IPC_64, CHECK_1 (buf));
+    if (result != -1 || errno != EINVAL)
+      return result;
+
+    __set_errno(save_errno);
+    if (cmd == IPC_SET)
+      {
+	old.ds.shm_perm.uid = buf->shm_perm.uid;
+	old.ds.shm_perm.gid = buf->shm_perm.gid;
+	old.ds.shm_perm.mode = buf->shm_perm.mode;
+	if (old.ds.shm_perm.uid != buf->shm_perm.uid ||
+	    old.ds.shm_perm.gid != buf->shm_perm.gid)
+	  {
+	    __set_errno (EINVAL);
+	    return -1;
+	  }
+      }
+    result = INLINE_SYSCALL (shmctl, 3, shmid, cmd, __ptrvalue (&old.ds));
+    if (result != -1 && (cmd == SHM_STAT || cmd == IPC_STAT))
+      {
+	memset(buf, 0, sizeof(*buf));
+	buf->shm_perm.__key = old.ds.shm_perm.__key;
+	buf->shm_perm.uid = old.ds.shm_perm.uid;
+	buf->shm_perm.gid = old.ds.shm_perm.gid;
+	buf->shm_perm.cuid = old.ds.shm_perm.cuid;
+	buf->shm_perm.cgid = old.ds.shm_perm.cgid;
+	buf->shm_perm.mode = old.ds.shm_perm.mode;
+	buf->shm_perm.__seq = old.ds.shm_perm.__seq;
+	buf->shm_atime = old.ds.shm_atime;
+	buf->shm_dtime = old.ds.shm_dtime;
+	buf->shm_ctime = old.ds.shm_ctime;
+	buf->shm_segsz = old.ds.shm_segsz;
+	buf->shm_nattch = old.ds.shm_nattch;
+	buf->shm_cpid = old.ds.shm_cpid;
+	buf->shm_lpid = old.ds.shm_lpid;
+      }
+#if __WORDSIZE != 32
+    else if (result != -1 && cmd == IPC_INFO)
+      {
+	struct shminfo *i = (struct shminfo *)buf;
+
+	memset(i, 0, sizeof(*i));
+	i->shmmax = old.info.shmmax;
+	i->shmmin = old.info.shmmin;
+	i->shmmni = old.info.shmmni;
+	i->shmseg = old.info.shmseg;
+	i->shmall = old.info.shmall;
+      }
+#endif
+    return result;
+  }
+#endif
+}
+
+versioned_symbol (libc, __new_shmctl, shmctl, GLIBC_2_2);
diff --git a/sysdeps/unix/sysv/linux/microblaze/shmdt.c b/sysdeps/unix/sysv/linux/microblaze/shmdt.c
new file mode 100644
index 0000000..58fef5f
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/shmdt.c
@@ -0,0 +1,35 @@
+/* Copyright (C) 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/shm.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+/* Detach shared memory segment starting at address specified by SHMADDR
+   from the caller's data segment.  */
+
+int
+shmdt (shmaddr)
+     const void *shmaddr;
+{
+  return INLINE_SYSCALL (shmdt, 1, __ptrvalue ((void *) shmaddr));
+}
diff --git a/sysdeps/unix/sysv/linux/microblaze/shmget.c b/sysdeps/unix/sysv/linux/microblaze/shmget.c
new file mode 100644
index 0000000..b49790e
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/shmget.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 1995, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/shm.h>
+#include <ipc_priv.h>
+#include <stdlib.h>		/* for definition of NULL */
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+/* Return an identifier for an shared memory segment of at least size SIZE
+   which is associated with KEY.  */
+
+int
+shmget (key, size, shmflg)
+     key_t key;
+     size_t size;
+     int shmflg;
+{
+  return INLINE_SYSCALL (shmget, 3, key, size, shmflg);
+}
diff --git a/sysdeps/unix/sysv/linux/microblaze/sigcontextinfo.h b/sysdeps/unix/sysv/linux/microblaze/sigcontextinfo.h
new file mode 100644
index 0000000..6a4399c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/sigcontextinfo.h
@@ -0,0 +1,22 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define SIGCONTEXT int _code, struct sigcontext *
+#define SIGCONTEXT_EXTRA_ARGS _code,
+#define GET_PC(ctx)	((void *) (ctx)->regs.pc)
+#define GET_FRAME(ctx)	((void *) (ctx)->regs.sp)
+#define GET_STACK(ctx)	((void *) (ctx)->regs.sp)
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
diff --git a/sysdeps/unix/sysv/linux/microblaze/socket.S b/sysdeps/unix/sysv/linux/microblaze/socket.S
new file mode 100644
index 0000000..3f886a2
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/socket.S
@@ -0,0 +1,129 @@
+/* Copyright (C) 1995, 1996, 1997, 1999, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep-cancel.h>
+#include <socketcall.h>
+
+#define P(a, b) P2(a, b)
+#define P2(a, b) a##b
+
+/* The socket-oriented system calls are handled unusally in Linux.
+   They are all gated through the single `socketcall' system call number.
+   `socketcall' takes two arguments: the first is the subcode, specifying
+   which socket function is being called; and the second is a pointer to
+   the arguments to the specific function.
+
+   The .S files for the other calls just #define socket and #include this.
+   They also #define a 'number-of-arguments' word in NARGS, which
+   defaults to 3.  */
+
+#ifndef NARGS
+#ifdef socket
+#error NARGS not defined
+#endif
+#define NARGS 3
+#endif
+
+/* Stack usage:
+   0 - r15 (return address)
+   4 - 12 args to syscall
+   16 - scratch for cancellation state
+   20 - scratch for return value
+*/
+#define stackadjust 24
+
+#ifndef __socket
+#ifndef NO_WEAK_ALIAS
+#define __socket P(__,socket)
+#else
+#define __socket socket
+#endif
+#endif
+
+	.text
+ENTRY(__socket)
+	cfi_startproc
+	addik r1,r1,-stackadjust
+	swi r15,r1,0
+	cfi_adjust_cfa_offset(stackadjust)
+#if NARGS >= 1
+	swi  r5,r1,stackadjust+4
+#endif
+#if NARGS >= 2
+	swi  r6,r1,stackadjust+8
+#endif
+#if NARGS >= 3
+	swi  r7,r1,stackadjust+12
+#endif
+#if NARGS >= 4
+	swi  r8,r1,stackadjust+16
+#endif
+#if NARGS >= 5
+	swi  r9,r1,stackadjust+20
+#endif
+#if NARGS >= 6
+	swi  r10,r1,stackadjust+24
+#endif
+/* The rest of the args (if any) are on the caller's stack already */
+
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P
+	bnei	r12,L(socket_cancel)
+#endif
+
+	addik	r12,r0,SYS_ify(socketcall)
+	addik	r5,r0,P(SOCKOP_,socket)
+	addik	r6,r1,stackadjust+4
+	brki	r14,8
+	addk	r0,r0,r0
+	lwi	r15,r1,0
+	addik	r1,r1,stackadjust
+	addik   r4,r0,-4095
+	cmpu	r4,r4,r3
+	bgei	r4,SYSCALL_ERROR_LABEL
+	rtsd	r15,8
+	addk	r0,r0,r0
+
+#if defined NEED_CANCELLATION && defined CENABLE
+L(socket_cancel):
+	CENABLE
+	swi	r3,r1,16
+	addik	r12,r0,SYS_ify(socketcall)
+	addik	r5,r0,P(SOCKOP_,socket)
+	addik	r6,r1,stackadjust+4
+	brki	r14,8
+	addk	r0,r0,r0
+	swi	r3,r1,20
+	lwi	r5,r1,16
+	CDISABLE
+	lwi	r3,r1,20
+	lwi	r15,r1,0
+	addik	r1,r1,stackadjust
+	addik   r4,r0,-4095
+	cmpu	r4,r4,r3
+	bgei	r4,SYSCALL_ERROR_LABEL
+	rtsd	r15,8
+	addk	r0,r0,r0
+#endif
+	cfi_endproc
+
+PSEUDO_END (__socket)
+
+#ifndef NO_WEAK_ALIAS
+weak_alias (__socket, socket)
+#endif
diff --git a/sysdeps/unix/sysv/linux/microblaze/sys/elf.h b/sysdeps/unix/sysv/linux/microblaze/sys/elf.h
new file mode 100644
index 0000000..d959cdc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/sys/elf.h
@@ -0,0 +1,26 @@
+/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_ELF_H
+#define _SYS_ELF_H	1
+
+#warning "This header is obsolete; use <sys/procfs.h> instead."
+
+#include <sys/procfs.h>
+
+#endif	/* _SYS_ELF_H */
diff --git a/sysdeps/unix/sysv/linux/microblaze/sys/procfs.h b/sysdeps/unix/sysv/linux/microblaze/sys/procfs.h
new file mode 100644
index 0000000..971b3ae
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/sys/procfs.h
@@ -0,0 +1,124 @@
+/* Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somewhat modelled after the file of the same name on SVR4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  It doesn't have anything to do with the /proc file
+   system, even though Linux has one.
+
+   Anyway, the whole purpose of this file is for GDB and GDB only.
+   Don't read too much into it.  Don't use it for anything other than
+   GDB unless you know what you are doing.  */
+
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+
+__BEGIN_DECLS
+
+/* Type for a general-purpose register.  */
+typedef unsigned long elf_greg_t;
+
+/* And the whole bunch of them.  We could have used `struct
+   user_regs_struct' directly in the typedef, but tradition says that
+   the register set is an array, which does have some peculiar
+   semantics, so leave it that way.  */
+#define ELF_NGREG (sizeof (struct user_regs_struct) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+/* Register set for the floating-point registers.  */
+typedef struct user_fpregs_struct elf_fpregset_t;
+
+
+/* Signal info.  */
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with Linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   GDB doesn't really use excluded.  */
+
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args.  */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+
+/* The rest of this file provides the types for emulation of the
+   Solaris <proc_service.h> interfaces that should be implemented by
+   users of libthread_db.  */
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore have only ine PID type.  */
+typedef __pid_t lwpid_t;
+
+/* Process status and info.  In the end we do provide typedefs for them.  */
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
diff --git a/sysdeps/unix/sysv/linux/microblaze/sys/reg.h b/sysdeps/unix/sysv/linux/microblaze/sys/reg.h
new file mode 100644
index 0000000..af67c48
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/sys/reg.h
@@ -0,0 +1,86 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_REG_H
+#define _SYS_REG_H	1
+
+/* Index into an array of 4 byte integers returned from ptrace for
+   location of the users' stored general purpose registers. */
+
+enum
+{
+  PT_D1 = 0,
+#define PT_D1 PT_D1
+  PT_D2 = 1,
+#define PT_D2 PT_D2
+  PT_D3 = 2,
+#define PT_D3 PT_D3
+  PT_D4 = 3,
+#define PT_D4 PT_D4
+  PT_D5 = 4,
+#define PT_D5 PT_D5
+  PT_D6 = 5,
+#define PT_D6 PT_D6
+  PT_D7 = 6,
+#define PT_D7 PT_D7
+  PT_A0 = 7,
+#define PT_A0 PT_A0
+  PT_A1 = 8,
+#define PT_A1 PT_A1
+  PT_A2 = 9,
+#define PT_A2 PT_A2
+  PT_A3 = 10,
+#define PT_A3 PT_A3
+  PT_A4 = 11,
+#define PT_A4 PT_A4
+  PT_A5 = 12,
+#define PT_A5 PT_A5
+  PT_A6 = 13,
+#define PT_A6 PT_A6
+  PT_D0 = 14,
+#define PT_D0 PT_D0
+  PT_USP = 15,
+#define PT_USP PT_USP
+  PT_ORIG_D0 = 16,
+#define PT_ORIG_D0 PT_ORIG_D0
+  PT_SR = 17,
+#define PT_SR PT_SR
+  PT_PC = 18,
+#define PT_PC PT_PC
+  PT_FP0 = 21,
+#define PT_FP0 PT_FP0
+  PT_FP1 = 24,
+#define PT_FP1 PT_FP1
+  PT_FP2 = 27,
+#define PT_FP2 PT_FP2
+  PT_FP3 = 30,
+#define PT_FP3 PT_FP3
+  PT_FP4 = 33,
+#define PT_FP4 PT_FP4
+  PT_FP5 = 36,
+#define PT_FP5 PT_FP5
+  PT_FP6 = 39,
+#define PT_FP6 PT_FP6
+  PT_FP7 = 42,
+#define PT_FP7 PT_FP7
+  PT_FPCR = 45,
+#define PT_FPCR PT_FPCR
+  PT_FPSR = 46,
+#define PT_FPSR PT_FPSR
+  PT_FPIAR = 47
+#define PT_FPIAR PT_FPIAR
+};
+
+#endif	/* _SYS_REG_H */
diff --git a/sysdeps/unix/sysv/linux/microblaze/sys/user.h b/sysdeps/unix/sysv/linux/microblaze/sys/user.h
new file mode 100644
index 0000000..987a694
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/sys/user.h
@@ -0,0 +1,77 @@
+/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_USER_H
+#define _SYS_USER_H	1
+
+/* The whole purpose of this file is for GDB and GDB only.  Don't read
+   too much into it.  Don't use it for anything other than GDB unless
+   you know what you are doing.  */
+
+struct user_fpregs_struct
+{
+  long int cwd;
+  long int swd;
+  long int twd;
+  long int fip;
+  long int fcs;
+  long int foo;
+  long int fos;
+  long int st_space [20];
+};
+
+struct user_regs_struct
+{
+  unsigned int gpr[32];
+  unsigned int pc;
+  unsigned int msr;
+  unsigned int ear;
+  unsigned int esr;
+  unsigned int fsr;
+  unsigned int btr;
+  unsigned int pvr[12];
+};
+
+struct user
+{
+  struct user_regs_struct	regs;
+  int				u_fpvalid;
+  struct user_fpregs_struct	i387;
+  unsigned long int		u_tsize;
+  unsigned long int		u_dsize;
+  unsigned long int		u_ssize;
+  unsigned long			start_code;
+  unsigned long			start_stack;
+  long int			signal;
+  int				reserved;
+  struct user_regs_struct*	u_ar0;
+  struct user_fpregs_struct*	u_fpstate;
+  unsigned long int		magic;
+  char				u_comm [32];
+  int				u_debugreg [8];
+};
+
+#define PAGE_SHIFT		12
+#define PAGE_SIZE		(1UL << PAGE_SHIFT)
+#define PAGE_MASK		(~(PAGE_SIZE-1))
+#define NBPG			PAGE_SIZE
+#define UPAGES			1
+#define HOST_TEXT_START_ADDR	(u.start_code)
+#define HOST_STACK_END_ADDR	(u.start_stack + u.u_ssize * NBPG)
+
+#endif	/* _SYS_USER_H */
diff --git a/sysdeps/unix/sysv/linux/microblaze/syscall.S b/sysdeps/unix/sysv/linux/microblaze/syscall.S
new file mode 100644
index 0000000..b270e0b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/syscall.S
@@ -0,0 +1,34 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+	.text
+ENTRY (syscall)
+	addk	r12,r0,r5
+	addk	r5,r0,r6
+	addk	r6,r0,r7
+	addk	r7,r0,r8
+	addk	r8,r0,r9
+	addk	r9,r0,r10
+	lwi	r10,r1,28
+	brki	r14,8
+	addk	r0,r0,r0
+	addik	r4,r0,-4095
+	cmpu	r4,r4,r3
+	bgei	r4,SYSCALL_ERROR_LABEL
+	rtsd	r15,8
+	nop
+PSEUDO_END (syscall)
diff --git a/sysdeps/unix/sysv/linux/microblaze/syscalls.list b/sysdeps/unix/sysv/linux/microblaze/syscalls.list
new file mode 100644
index 0000000..98d3066
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/syscalls.list
@@ -0,0 +1,5 @@
+# File name	Caller	Syscall name	Args	Strong name	Weak names
+
+cacheflush	EXTRA	cacheflush	i:iiii	__cacheflush	cacheflush
+oldgetrlimit	EXTRA	getrlimit	i:ip	__old_getrlimit	getrlimit@GLIBC_2.0
+oldsetrlimit	EXTRA	setrlimit	i:ip	__old_setrlimit	setrlimit@GLIBC_2.0
diff --git a/sysdeps/unix/sysv/linux/microblaze/sysdep.S b/sysdeps/unix/sysv/linux/microblaze/sysdep.S
new file mode 100644
index 0000000..b27e776
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/sysdep.S
@@ -0,0 +1,43 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+
+/* The following code is only used in the shared library when we
+   compile the reentrant version.  Otherwise each system call defines
+   each own version.  */
+
+#ifndef	PIC
+
+/* The syscall stubs jump here when they detect an error.  */
+
+#undef CALL_MCOUNT
+#define CALL_MCOUNT /* Don't insert the profiling call, it clobbers %d0.  */
+
+#if 0
+.globl C_SYMBOL_NAME(errno)
+#endif
+	.text
+ENTRY (__syscall_error)
+	rsubk	r3,r3,r0
+#if 0
+	/* REVISIT - Make this TLS reference */
+	swi	r3,r0,C_SYMBOL_NAME(errno)
+#endif
+	rtsd	r15,8
+	addik	r3,r0,-1	/* delay slot */
+END (__syscall_error)
+#endif /* PIC */
diff --git a/sysdeps/unix/sysv/linux/microblaze/sysdep.h b/sysdeps/unix/sysv/linux/microblaze/sysdep.h
new file mode 100644
index 0000000..e419ace
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/sysdep.h
@@ -0,0 +1,406 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/microblaze/sysdep.h>
+#include <sys/syscall.h>
+
+/* Defines RTLD_PRIVATE_ERRNO.  */
+#include <dl-sysdep.h>
+
+/* For Linux we can use the system call table in the header file
+	/usr/include/asm/unistd.h
+   of the kernel.  But these symbols do not follow the SYS_* syntax
+   so we have to redefine the `SYS_ify' macro here.  */
+#undef SYS_ify
+#ifdef __STDC__
+# define SYS_ify(syscall_name)	__NR_##syscall_name
+#else
+# define SYS_ify(syscall_name)	__NR_/**/syscall_name
+#endif
+
+#ifdef __ASSEMBLER__
+
+/* In microblaze ABI function call arguments are passed in registers
+   r5...r10. The return value is stored in r3 (or r3:r4 regiters pair).
+   Linux syscall uses the same convention with the addition that the
+   syscall number is passed in r12. To enter the kernel "brki r14,8"
+   instruction is used.
+   None of the abovementioned registers are presumed across function call
+   or syscall.
+*/
+/* Linux uses a negative return value to indicate syscall errors, unlike
+   most Unices, which use the condition codes' carry flag.
+
+   Since version 2.1 the return value of a system call might be negative
+   even if the call succeeded.  E.g., the `lseek' system call might return
+   a large offset.  Therefore we must not anymore test for < 0, but test
+   for a real error by making sure the value in %d0 is a real error
+   number.  Linus said he will make sure the no syscall returns a value
+   in -1 .. -4095 as a valid result so we can savely test with -4095.  */
+
+/* We don't want the label for the error handler to be visible in the symbol
+   table when we define it here.  */
+#ifdef PIC
+#define SYSCALL_ERROR_LABEL 0f
+#else
+#define SYSCALL_ERROR_LABEL __syscall_error
+#endif
+
+#undef PSEUDO
+#define	PSEUDO(name, syscall_name, args)		\
+  .text;						\
+  ENTRY (name)						\
+    DO_CALL (syscall_name, args);			\
+    addik r12,r0,-4095;					\
+    cmpu  r12,r12,r3;					\
+    bgei r12,SYSCALL_ERROR_LABEL;
+
+#undef PSEUDO_END
+#define PSEUDO_END(name)				\
+  SYSCALL_ERROR_HANDLER;				\
+  END (name)
+
+#undef PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args)	\
+  .text;						\
+  ENTRY (name)						\
+    DO_CALL (syscall_name, args);
+
+#undef PSEUDO_END_NOERRNO
+#define PSEUDO_END_NOERRNO(name)			\
+  END (name)
+
+/* The function has to return the error code.  */
+#undef	PSEUDO_ERRVAL
+#define	PSEUDO_ERRVAL(name, syscall_name, args)		\
+  .text;						\
+  ENTRY (name)						\
+    DO_CALL (syscall_name, args);			\
+
+#undef	PSEUDO_END_ERRVAL
+#define	PSEUDO_END_ERRVAL(name) \
+  END (name)
+
+#define ret_NOERRNO \
+    rtsd r15,8; addk r0,r0,r0;
+
+#define ret_ERRVAL \
+    rtsd r15,8; rsubk r3,r3,r0;
+
+#ifdef PIC
+#define SYSCALL_ERROR_LABEL_DCL 0
+# if RTLD_PRIVATE_ERRNO
+#  define SYSCALL_ERROR_HANDLER				\
+SYSCALL_ERROR_LABEL_DCL:					\
+    mfs   r12,rpc;					\
+    addik r12,r12,_GLOBAL_OFFSET_TABLE_+8;		\
+    lwi   r12,r12,rtld_errno@GOT;			\
+    rsubk r3,r3,r0;					\
+    swi	  r3,r12,0;					\
+    rtsd  r15,8;					\
+    addik r3,r0,-1;
+# else /* !RTLD_PRIVATE_ERRNO */
+/* Store (-r3) into errno through the GOT.  */
+#  if defined _LIBC_REENTRANT
+#  define SYSCALL_ERROR_HANDLER				\
+SYSCALL_ERROR_LABEL_DCL:					\
+    addik r1,r1,-16;					\
+    swi   r15,r1,0;					\
+    swi   r20,r1,8;					\
+    rsubk r3,r3,r0;					\
+    swi   r3,r1,12;					\
+    mfs   r20,rpc;					\
+    addik r20,r20,_GLOBAL_OFFSET_TABLE_+8;		\
+    brlid r15,__errno_location@PLT;			\
+    nop;						\
+    lwi   r4,r1,12;					\
+    swi   r4,r3,0;					\
+    lwi   r20,r1,8;					\
+    lwi   r15,r1,0;					\
+    addik r1,r1,16;					\
+    rtsd  r15,8;					\
+    addik r3,r0,-1;
+#  else /* !_LIBC_REENTRANT */
+#  define SYSCALL_ERROR_HANDLER				\
+SYSCALL_ERROR_LABEL_DCL:					\
+    mfs   r12,rpc;					\
+    addik r12,r12,_GLOBAL_OFFSET_TABLE_+8;		\
+    lwi   r12,r12,errno@GOT;				\
+    rsubk r3,r3,r0;					\
+    swi	  r3,r12,0;					\
+    rtsd  r15,8;					\
+    addik r3,r0,-1;
+#  endif /* _LIBC_REENTRANT */
+# endif /* RTLD_PRIVATE_ERRNO */
+#else
+# define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
+#endif /* PIC */
+
+#define DO_CALL(syscall_name, args)			      		      \
+    addik r12,r0,SYS_ify (syscall_name);				      \
+    brki  r14,8;							      \
+    addk  r0,r0,r0;
+
+#else /* not __ASSEMBLER__ */
+
+/* Define a macro which expands into the inline wrapper code for a system
+   call.  */
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)				\
+  ({ unsigned int _sys_result = INTERNAL_SYSCALL (name, , nr, args);	\
+     if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (_sys_result, ), 0))\
+       {								\
+	 __set_errno (INTERNAL_SYSCALL_ERRNO (_sys_result, ));		\
+	 _sys_result = (unsigned int) -1;				\
+       }								\
+     (int) _sys_result; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+/* Define a macro which expands inline into the wrapper code for a system
+   call.  This use is for internal calls that do not need to handle errors
+   normally.  It will never touch errno.  This returns just what the kernel
+   gave back.  */
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...)	\
+  INTERNAL_SYSCALL_##nr(name,args)
+
+#define SYSCALL_CLOBBERS_6 "r11", "r4", "memory"
+#define SYSCALL_CLOBBERS_5 "r10", SYSCALL_CLOBBERS_6
+#define SYSCALL_CLOBBERS_4 "r9", SYSCALL_CLOBBERS_5
+#define SYSCALL_CLOBBERS_3 "r8", SYSCALL_CLOBBERS_4
+#define SYSCALL_CLOBBERS_2 "r7", SYSCALL_CLOBBERS_3
+#define SYSCALL_CLOBBERS_1 "r6", SYSCALL_CLOBBERS_2
+#define SYSCALL_CLOBBERS_0 "r5", SYSCALL_CLOBBERS_1
+
+#define INTERNAL_SYSCALL_0(name,dummy)			\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = SYS_ify(name);	\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r12)					\
+      : SYSCALL_CLOBBERS_0 ); ret;			\
+  })
+
+#define INTERNAL_SYSCALL_NCS_0(number,dummy)			\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = number;	\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r12)					\
+      : SYSCALL_CLOBBERS_0 ); ret;			\
+  })
+
+#define INTERNAL_SYSCALL_1(name,arg1)			\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = SYS_ify(name);	\
+    register int __r5 __asm__("r5") = arg1;		\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r5), "r"(__r12)				\
+      : SYSCALL_CLOBBERS_1 ); ret;			\
+  })
+
+#define INTERNAL_SYSCALL_NCS_1(number,arg1)			\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = number;	\
+    register int __r5 __asm__("r5") = arg1;		\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r5), "r"(__r12)				\
+      : SYSCALL_CLOBBERS_1 ); ret;			\
+  })
+
+#define INTERNAL_SYSCALL_2(name,arg1,arg2)		\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = SYS_ify(name);	\
+    register int __r5 __asm__("r5") = arg1;		\
+    register int __r6 __asm__("r6") = arg2;		\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r5), "r"(__r6), "r"(__r12)		\
+      : SYSCALL_CLOBBERS_2 ); ret;			\
+  })
+
+#define INTERNAL_SYSCALL_NCS_2(number,arg1,arg2)		\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = number;	\
+    register int __r5 __asm__("r5") = arg1;		\
+    register int __r6 __asm__("r6") = arg2;		\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r5), "r"(__r6), "r"(__r12)		\
+      : SYSCALL_CLOBBERS_2 ); ret;			\
+  })
+
+#define INTERNAL_SYSCALL_3(name,arg1,arg2,arg3)		\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = SYS_ify(name);	\
+    register int __r5 __asm__("r5") = arg1;		\
+    register int __r6 __asm__("r6") = arg2;		\
+    register int __r7 __asm__("r7") = arg3;		\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r5), "r"(__r6), "r"(__r7), "r"(__r12)	\
+      : SYSCALL_CLOBBERS_3 ); ret;			\
+  })
+
+#define INTERNAL_SYSCALL_NCS_3(number,arg1,arg2,arg3)		\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = number;	        \
+    register int __r5 __asm__("r5") = arg1;		\
+    register int __r6 __asm__("r6") = arg2;		\
+    register int __r7 __asm__("r7") = arg3;		\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r5), "r"(__r6), "r"(__r7), "r"(__r12)	\
+      : SYSCALL_CLOBBERS_3 ); ret;			\
+  })
+
+#define INTERNAL_SYSCALL_4(name,arg1,arg2,arg3,arg4)	\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = SYS_ify(name);	\
+    register int __r5 __asm__("r5") = arg1;		\
+    register int __r6 __asm__("r6") = arg2;		\
+    register int __r7 __asm__("r7") = arg3;		\
+    register int __r8 __asm__("r8") = arg4;		\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r5), "r"(__r6), "r"(__r7), "r"(__r8),"r"(__r12)	\
+      : SYSCALL_CLOBBERS_4 ); ret;			\
+  })
+
+#define INTERNAL_SYSCALL_NCS_4(number,arg1,arg2,arg3,arg4)	\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = number;	\
+    register int __r5 __asm__("r5") = arg1;		\
+    register int __r6 __asm__("r6") = arg2;		\
+    register int __r7 __asm__("r7") = arg3;		\
+    register int __r8 __asm__("r8") = arg4;		\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r5), "r"(__r6), "r"(__r7), "r"(__r8),"r"(__r12)	\
+      : SYSCALL_CLOBBERS_4 ); ret;			\
+  })
+
+#define INTERNAL_SYSCALL_5(name,arg1,arg2,arg3,arg4,arg5)	\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = SYS_ify(name);	\
+    register int __r5 __asm__("r5") = arg1;		\
+    register int __r6 __asm__("r6") = arg2;		\
+    register int __r7 __asm__("r7") = arg3;		\
+    register int __r8 __asm__("r8") = arg4;		\
+    register int __r9 __asm__("r9") = arg5;		\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r5), "r"(__r6), "r"(__r7), "r"(__r8),"r"(__r9), "r"(__r12)	\
+      : SYSCALL_CLOBBERS_5 ); ret;			\
+  })
+
+#define INTERNAL_SYSCALL_NCS_5(number,arg1,arg2,arg3,arg4,arg5)	\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = number;		\
+    register int __r5 __asm__("r5") = arg1;		\
+    register int __r6 __asm__("r6") = arg2;		\
+    register int __r7 __asm__("r7") = arg3;		\
+    register int __r8 __asm__("r8") = arg4;		\
+    register int __r9 __asm__("r9") = arg5;		\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r5), "r"(__r6), "r"(__r7), "r"(__r8),"r"(__r9), "r"(__r12)	\
+      : SYSCALL_CLOBBERS_5 ); ret;			\
+  })
+
+#define INTERNAL_SYSCALL_6(name,arg1,arg2,arg3,arg4,arg5,arg6)	\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = SYS_ify(name);	\
+    register int __r5 __asm__("r5") = arg1;		\
+    register int __r6 __asm__("r6") = arg2;		\
+    register int __r7 __asm__("r7") = arg3;		\
+    register int __r8 __asm__("r8") = arg4;		\
+    register int __r9 __asm__("r9") = arg5;		\
+    register int __r10 __asm__("r10") = arg6;		\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r5), "r"(__r6), "r"(__r7), "r"(__r8),"r"(__r9), "r"(__r10), "r"(__r12)	\
+      : SYSCALL_CLOBBERS_6 ); ret;			\
+  })
+
+
+#define INTERNAL_SYSCALL_NCS_6(number,arg1,arg2,arg3,arg4,arg5,arg6)	\
+  ({ \
+    register int ret __asm__("r3");			\
+    register int __r12 __asm__("r12") = number;		\
+    register int __r5 __asm__("r5") = arg1;		\
+    register int __r6 __asm__("r6") = arg2;		\
+    register int __r7 __asm__("r7") = arg3;		\
+    register int __r8 __asm__("r8") = arg4;		\
+    register int __r9 __asm__("r9") = arg5;		\
+    register int __r10 __asm__("r10") = arg6;		\
+    __asm__ __volatile__( "brki r14,8; nop;"		\
+      : "=r"(ret)					\
+      : "r"(__r5), "r"(__r6), "r"(__r7), "r"(__r8),"r"(__r9), "r"(__r10), "r"(__r12)	\
+      : SYSCALL_CLOBBERS_6 ); ret;			\
+  })
+
+#define INTERNAL_SYSCALL_NCS(number, err, nr, args...)		\
+	INTERNAL_SYSCALL_NCS_##nr(number, args)
+
+#if 0
+/* We can't implement non-constant syscalls directly since the syscall
+   number is normally encoded in the instruction.  So use SYS_syscall.  */
+#define INTERNAL_SYSCALL_NCS(number, err, nr, args...)		\
+	INTERNAL_SYSCALL_NCS_##nr (number, err, args)
+
+#define INTERNAL_SYSCALL_NCS_0(number, err, args...)		\
+	INTERNAL_SYSCALL (syscall, err, 1, number, args)
+#define INTERNAL_SYSCALL_NCS_1(number, err, args...)		\
+	INTERNAL_SYSCALL (syscall, err, 2, number, args)
+#define INTERNAL_SYSCALL_NCS_2(number, err, args...)		\
+	INTERNAL_SYSCALL (syscall, err, 3, number, args)
+#define INTERNAL_SYSCALL_NCS_3(number, err, args...)		\
+	INTERNAL_SYSCALL (syscall, err, 4, number, args)
+#define INTERNAL_SYSCALL_NCS_4(number, err, args...)		\
+	INTERNAL_SYSCALL (syscall, err, 5, number, args)
+#define INTERNAL_SYSCALL_NCS_5(number, err, args...)		\
+	INTERNAL_SYSCALL (syscall, err, 6, number, args)
+#endif
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)		\
+  ((unsigned int) (val) >= -4095U)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)	(-(val))
+
+/* Pointer mangling is not yet supported for Microblaze.  */
+#define PTR_MANGLE(var) (void) (var)
+#define PTR_DEMANGLE(var) (void) (var)
+
+#endif /* not __ASSEMBLER__ */
diff --git a/sysdeps/unix/sysv/linux/microblaze/versionsort64.c b/sysdeps/unix/sysv/linux/microblaze/versionsort64.c
new file mode 100644
index 0000000..144b691
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/versionsort64.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/versionsort64.c>
diff --git a/sysdeps/unix/sysv/linux/microblaze/vfork.S b/sysdeps/unix/sysv/linux/microblaze/vfork.S
new file mode 100644
index 0000000..ca99596
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/vfork.S
@@ -0,0 +1,45 @@
+/* The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+#include <kernel-features.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+
+#ifdef __NR_vfork
+
+	DO_CALL (vfork, 0)
+#if 0
+	/* REVISIT */
+	PSEUDO_RET
+#endif
+#else
+	DO_CALL (fork, 0)
+#if 0
+	PSEUDO_RET
+#endif
+#endif
+
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
diff --git a/sysdeps/unix/sysv/linux/microblaze/xstat.c b/sysdeps/unix/sysv/linux/microblaze/xstat.c
new file mode 100644
index 0000000..e9869f5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/microblaze/xstat.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/xstat.c>
-- 
1.7.1

